{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ethopy","text":"<p>Python Boilerplate contains all the boilerplate you need to create a Python package.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://alexevag.github.io/ethopy</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"behavior/","title":"Core Behavior module","text":""},{"location":"behavior/#ethopy.core.Behavior.Activity","title":"<code> Activity        </code>  <code>dataclass</code>","text":"<p>Activity(**kwargs)</p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>class Activity(dj.Manual):\n    definition = \"\"\"\n    # Mouse behavioral response\n    -&gt; experiment.Trial  \n    \"\"\"\n\n    class Proximity(dj.Part):\n        definition = \"\"\"\n        # Center port information\n        -&gt; Activity\n        port                 : tinyint          # port id\n        time\t     \t  \t : int           \t# time from session start (ms)\n        ---\n        in_position          : tinyint\n        \"\"\"\n\n        def plot(self, **kwargs):\n            params = {'range': (0, 1000),\n                      'bins': 100, **kwargs}\n            d = np.diff(self.fetch('time'))\n            plt.hist(d, params['bins'], range=params['range'])\n\n    class Lick(dj.Part):\n        definition = \"\"\"\n        # Lick timestamps\n        -&gt; Activity\n        port                 : tinyint          # port id\n        time\t     \t  \t : int           \t# time from session start (ms)\n        \"\"\"\n\n        def plot(self, **kwargs):\n            params = {'port_colors': ['red', 'blue'],  # set function parameters with defaults\n                      'xlim': [-500, 10000],\n                      'figsize': (15, 15),\n                      'dotsize': 4, **kwargs}\n\n            key = {\"animal_id\" : np.unique(self.fetch('animal_id'))[0],\n                   \"session\" : np.unique(self.fetch('session'))[0]}\n\n            conds = ((Trial &amp; key)).getGroups()  # conditions in trials for animal\n\n            fig, axs = plt.subplots(round(len(conds) ** .5), -(-len(conds) // round(len(conds) ** .5)),\n                                    sharex=True, figsize=params['figsize'])\n\n            for idx, cond in enumerate(conds):  # iterate through conditions\n                selected_trials = (self.proj(ltime = 'time') * (((Trial &amp; key) - Trial.Aborted()) &amp; cond)).proj(ltime = 'ltime - time')\n                trials, ports, times = selected_trials.fetch('trial_idx', 'port', 'ltime', order_by='trial_idx')\n                un_trials, idx_trials = np.unique(trials, return_inverse=True)  # get unique trials\n                axs.item(idx).scatter(times, idx_trials, params['dotsize'],  # plot all of them\n                                      c=np.array(params['port_colors'])[ports - 1])\n                axs.item(idx).axvline(x=0, color='green', linestyle='-')\n\n                name = f'Object: {cond[0][5]}, Response Port: {cond[0][8]}'\n                #perf = len(np.unique((selected_trials &amp; f'port = {cond[0][8]}').fetch('trial_idx')))/len(un_trials)\n                perf = len(Trial &amp; selected_trials &amp; Rewards.proj(rtime = 'time'))/len(un_trials)\n                title = f'{name}, Performance:{perf:.2f}'\n\n                axs.item(idx).set_title(title, color=np.array(params['port_colors'])[cond[0][8] - 1],\n                                        fontsize=9)\n                axs.item(idx).invert_yaxis()\n            plt.xlim(params['xlim'])\n            plt.show()\n\n    class Touch(dj.Part):\n        definition = \"\"\"\n        # Touch timestamps\n        -&gt; Activity\n        loc_x               : int               # x touch location\n        loc_y               : int               # y touch location\n        time\t     \t    : int           \t# time from session start (ms)\n        \"\"\"\n\n    class Position(dj.Part):\n        definition = \"\"\"\n        # 2D possition timestamps\n        -&gt; Activity\n        loc_x               : float               # x 2d location\n        loc_y               : float               # y 2d location\n        theta               : float               # direction in space\n        time\t     \t    : int           \t# time from session start (ms)\n        \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.Behavior.Behavior","title":"<code> Behavior        </code>","text":"<p>This class handles the behavior variables </p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>class Behavior:\n    \"\"\" This class handles the behavior variables \"\"\"\n    cond_tables, interface, required_fields, curr_cond, response, licked_port, logging = [], [], [], [], [], 0, False\n    default_key, reward_amount, choice_history, reward_history = dict(), dict(), list(), list()\n\n    def setup(self, exp):\n        self.params = exp.params\n        self.exp = exp\n        self.logger = exp.logger\n        self.choices = np.array(np.empty(0))\n        self.choice_history = list()  # History term for bias calculation\n        self.reward_history = list()  # History term for performance calculation\n        self.punish_history = list()\n        self.reward_amount = dict()\n        self.response, self.last_lick = Activity(), Activity()\n        self.response_queue = Queue(maxsize = 4)\n        self.logging = True\n        interface_module = (experiment.SetupConfiguration &amp; {'setup_conf_idx': exp.params['setup_conf_idx']}\n                            ).fetch('interface')[0]\n        interface = getattr(import_module(f'ethopy.Interfaces.{interface_module}'), interface_module)\n        self.interface = interface(exp=exp, beh=self)\n        self.interface.load_calibration()\n\n    def is_ready(self, init_duration, since=0):\n        return True, 0\n\n    def get_response(self, since:int=0, clear:bool=True) -&gt; bool:\n            \"\"\"\n            Return a boolean indicating whether there is any response since the given time.\n\n            Args:\n                since (int, optional): Time in milliseconds. Defaults to 0.\n                clear (bool, optional): If True, clears any existing response before checking for new responses. \n                                        Defaults to True.\n\n            Returns:\n                bool: True if there is any valid response since the given time, False otherwise.\n            \"\"\"\n\n            if self.interface.__class__.__name__ == 'DummyPorts': self.interface._get_events()\n\n            # set a flag to indicate whether there is a valid response since the given time\n            _valid_response = False\n\n            # clear existing response if clear is True\n            if clear:\n                self.response = Activity()\n                self.licked_port = 0\n\n            # loop through the response queue and check if there is any response since the given time\n            # keeps only the response that is oldest and get rest of the queue clear\n            while not self.response_queue.empty():\n                _response = self.response_queue.get()\n                if not _valid_response and _response.time &gt;= since and _response.port:\n                    self.response = _response \n                    _valid_response = True\n\n            # return True if there is any valid response since the given time, False otherwise\n            if _valid_response: return True\n            return False\n\n    def is_licking(self, since:int=0, reward:bool=False, clear:bool=True) -&gt; int:\n        \"\"\"checks if there is any licking since the given time\n\n        is_licking is used in two ways:\n        1. to check if there is any licking since the given time\n        2. in case flag reward == True, to check if there is any licking since the given time \n           and also if the licked port is a reward port only then return the licked port number \n           else return 0\n\n        Args:\n            since (int, optional): Time in milliseconds. Defaults to 0.\n            reward (bool, optional): False. Defaults to False.\n            clear (bool, optional): if True reset last_lick to default Activity. Defaults to True.\n\n        Returns:\n            int: licked port number else 0\n        \"\"\"\n        if self.interface.__class__.__name__ == 'DummyPorts': self.interface._get_events()\n\n        # check if there is any licking since the given time\n        if self.last_lick.time &gt;= since and self.last_lick.port:\n            # if reward == False return the licked port number\n            # if reward == True check if the licked port is alse a reward port\n            if not reward or (reward and self.last_lick.reward):\n                self.licked_port = self.last_lick.port\n            else: \n                self.licked_port = 0\n        else: \n            self.licked_port = 0\n        # by default if it licked since the last time this function was called\n        if clear: self.last_lick = Activity() \n        return self.licked_port\n\n    def reward(self):\n        return True\n\n    def punish(self):\n        pass\n\n    def exit(self):\n        self.logging = False\n\n    def log_activity(self, activity_key:dict):\n        \"\"\"log the activity of the animal in the database, update the last_lick, licked_port variables, \n        append to the response queue if the queue is not full and return the time of the activity \n\n        Args:\n            activity_key (dict): _description_\n\n        Returns:\n            int: Time in milliseconds of the activity\n        \"\"\"\n        activity = Activity(**activity_key)\n        # if activity.time is not set, set it to the current time\n        if not activity.time: activity.time = self.logger.logger_timer.elapsed_time()\n        key = {**self.logger.trial_key, **activity.__dict__}\n        # log the activity in the database\n        if self.exp.running and self.logging:\n            self.logger.log('Activity', key, schema='behavior', priority=10)\n            self.logger.log('Activity.' + activity.type, key, schema='behavior')\n        # if activity.type == 'Response': append to the response queue\n        if activity.response:\n            if self.response_queue.full(): self.response_queue.get()\n            self.response_queue.put(activity)\n        # get the last lick and licked port to use it in is_licking function\n        if activity.type == 'Lick': self.last_lick = activity; self.licked_port = activity.port\n        return key['time']\n\n    def log_reward(self, reward_amount):\n        if isinstance(self.curr_cond['reward_port'], list):\n            self.curr_cond['reward_port'] = [self.licked_port]\n            self.curr_cond['response_port'] = [self.licked_port]\n        self.logger.log('Rewards', {**self.curr_cond, 'reward_amount': reward_amount}, schema='behavior')\n\n    def make_conditions(self, conditions):\n        \"\"\"generate and store stimulus condition hashes\"\"\"\n        if self.cond_tables:\n            for cond in conditions:\n                assert np.all([field in cond for field in self.required_fields])\n                cond.update({**self.default_key, **cond, 'behavior_class': self.cond_tables[0]})\n            return dict(conditions=conditions, condition_tables=['BehCondition'] + self.cond_tables,\n                        schema='behavior', hsh='beh_hash')\n        else:\n            for cond in conditions:\n                cond.update({**self.default_key, **cond, 'behavior_class': 'None'})\n            return dict(conditions=conditions, condition_tables=[], schema='behavior')\n\n    def prepare(self, condition):\n        self.curr_cond = condition\n        self.reward_amount = self.interface.calc_pulse_dur(condition['reward_amount'])\n        self.logger.log('BehCondition.Trial', dict(beh_hash=self.curr_cond['beh_hash']),\n                        schema='behavior')\n\n    def update_history(self, choice=np.nan, reward=np.nan, punish=np.nan):\n        if np.isnan(choice) and (~np.isnan(reward) or ~np.isnan(punish)) and self.response.time &gt; 0: choice = self.response.port\n        self.choice_history.append(choice)\n        self.reward_history.append(reward)\n        self.punish_history.append(punish)\n        self.logger.total_reward = np.nansum(self.reward_history)\n\n    def get_false_history(self, h=10):\n        idx = np.nan_to_num(self.punish_history)\n        return np.nansum(np.cumprod(np.flip(idx[-h:], axis=0)))\n\n    def is_sleep_time(self):\n        now = datetime.now()\n        start_time = self.logger.setup_info['start_time']\n        if isinstance(start_time, str):\n            dt = datetime.strptime(start_time, '%H:%M:%S')\n            start_time = timedelta(seconds=(dt.hour*3600 + dt.minute*60 + dt.second))\n        stop_time = self.logger.setup_info['stop_time']\n        if isinstance(stop_time, str):\n            dt = datetime.strptime(stop_time, '%H:%M:%S')\n            stop_time = timedelta(seconds=(dt.hour * 3600 + dt.minute * 60 + dt.second))\n\n        start = now.replace(hour=0, minute=0, second=0) + start_time\n        stop = now.replace(hour=0, minute=0, second=0) + stop_time\n        if stop &lt; start:\n            stop = stop + timedelta(days=1)\n        time_restriction = now &lt; start or now &gt; stop\n        return time_restriction\n\n    def is_hydrated(self, rew=False):\n        if rew:\n            return self.logger.total_reward &gt;= rew\n        elif self.params['max_reward']:\n            return self.logger.total_reward &gt;= self.params['max_reward']\n        else:\n            return False\n</code></pre>"},{"location":"behavior/#ethopy.core.Behavior.Behavior.get_response","title":"<code>get_response(self, since=0, clear=True)</code>","text":"<p>Return a boolean indicating whether there is any response since the given time.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>int</code> <p>Time in milliseconds. Defaults to 0.</p> <code>0</code> <code>clear</code> <code>bool</code> <p>If True, clears any existing response before checking for new responses.                      Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if there is any valid response since the given time, False otherwise.</p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>def get_response(self, since:int=0, clear:bool=True) -&gt; bool:\n        \"\"\"\n        Return a boolean indicating whether there is any response since the given time.\n\n        Args:\n            since (int, optional): Time in milliseconds. Defaults to 0.\n            clear (bool, optional): If True, clears any existing response before checking for new responses. \n                                    Defaults to True.\n\n        Returns:\n            bool: True if there is any valid response since the given time, False otherwise.\n        \"\"\"\n\n        if self.interface.__class__.__name__ == 'DummyPorts': self.interface._get_events()\n\n        # set a flag to indicate whether there is a valid response since the given time\n        _valid_response = False\n\n        # clear existing response if clear is True\n        if clear:\n            self.response = Activity()\n            self.licked_port = 0\n\n        # loop through the response queue and check if there is any response since the given time\n        # keeps only the response that is oldest and get rest of the queue clear\n        while not self.response_queue.empty():\n            _response = self.response_queue.get()\n            if not _valid_response and _response.time &gt;= since and _response.port:\n                self.response = _response \n                _valid_response = True\n\n        # return True if there is any valid response since the given time, False otherwise\n        if _valid_response: return True\n        return False\n</code></pre>"},{"location":"behavior/#ethopy.core.Behavior.Behavior.is_licking","title":"<code>is_licking(self, since=0, reward=False, clear=True)</code>","text":"<p>checks if there is any licking since the given time</p> <p>is_licking is used in two ways: 1. to check if there is any licking since the given time 2. in case flag reward == True, to check if there is any licking since the given time     and also if the licked port is a reward port only then return the licked port number     else return 0</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>int</code> <p>Time in milliseconds. Defaults to 0.</p> <code>0</code> <code>reward</code> <code>bool</code> <p>False. Defaults to False.</p> <code>False</code> <code>clear</code> <code>bool</code> <p>if True reset last_lick to default Activity. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>licked port number else 0</p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>def is_licking(self, since:int=0, reward:bool=False, clear:bool=True) -&gt; int:\n    \"\"\"checks if there is any licking since the given time\n\n    is_licking is used in two ways:\n    1. to check if there is any licking since the given time\n    2. in case flag reward == True, to check if there is any licking since the given time \n       and also if the licked port is a reward port only then return the licked port number \n       else return 0\n\n    Args:\n        since (int, optional): Time in milliseconds. Defaults to 0.\n        reward (bool, optional): False. Defaults to False.\n        clear (bool, optional): if True reset last_lick to default Activity. Defaults to True.\n\n    Returns:\n        int: licked port number else 0\n    \"\"\"\n    if self.interface.__class__.__name__ == 'DummyPorts': self.interface._get_events()\n\n    # check if there is any licking since the given time\n    if self.last_lick.time &gt;= since and self.last_lick.port:\n        # if reward == False return the licked port number\n        # if reward == True check if the licked port is alse a reward port\n        if not reward or (reward and self.last_lick.reward):\n            self.licked_port = self.last_lick.port\n        else: \n            self.licked_port = 0\n    else: \n        self.licked_port = 0\n    # by default if it licked since the last time this function was called\n    if clear: self.last_lick = Activity() \n    return self.licked_port\n</code></pre>"},{"location":"behavior/#ethopy.core.Behavior.Behavior.log_activity","title":"<code>log_activity(self, activity_key)</code>","text":"<p>log the activity of the animal in the database, update the last_lick, licked_port variables,  append to the response queue if the queue is not full and return the time of the activity </p> <p>Parameters:</p> Name Type Description Default <code>activity_key</code> <code>dict</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>Time in milliseconds of the activity</p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>def log_activity(self, activity_key:dict):\n    \"\"\"log the activity of the animal in the database, update the last_lick, licked_port variables, \n    append to the response queue if the queue is not full and return the time of the activity \n\n    Args:\n        activity_key (dict): _description_\n\n    Returns:\n        int: Time in milliseconds of the activity\n    \"\"\"\n    activity = Activity(**activity_key)\n    # if activity.time is not set, set it to the current time\n    if not activity.time: activity.time = self.logger.logger_timer.elapsed_time()\n    key = {**self.logger.trial_key, **activity.__dict__}\n    # log the activity in the database\n    if self.exp.running and self.logging:\n        self.logger.log('Activity', key, schema='behavior', priority=10)\n        self.logger.log('Activity.' + activity.type, key, schema='behavior')\n    # if activity.type == 'Response': append to the response queue\n    if activity.response:\n        if self.response_queue.full(): self.response_queue.get()\n        self.response_queue.put(activity)\n    # get the last lick and licked port to use it in is_licking function\n    if activity.type == 'Lick': self.last_lick = activity; self.licked_port = activity.port\n    return key['time']\n</code></pre>"},{"location":"behavior/#ethopy.core.Behavior.Behavior.make_conditions","title":"<code>make_conditions(self, conditions)</code>","text":"<p>generate and store stimulus condition hashes</p> Source code in <code>ethopy/core/Behavior.py</code> <pre><code>def make_conditions(self, conditions):\n    \"\"\"generate and store stimulus condition hashes\"\"\"\n    if self.cond_tables:\n        for cond in conditions:\n            assert np.all([field in cond for field in self.required_fields])\n            cond.update({**self.default_key, **cond, 'behavior_class': self.cond_tables[0]})\n        return dict(conditions=conditions, condition_tables=['BehCondition'] + self.cond_tables,\n                    schema='behavior', hsh='beh_hash')\n    else:\n        for cond in conditions:\n            cond.update({**self.default_key, **cond, 'behavior_class': 'None'})\n        return dict(conditions=conditions, condition_tables=[], schema='behavior')\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#ethopy.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>ethopy/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/alexevag/testcore/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>EthoPy could always use more documentation, whether as part of the official EthoPy docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/alexevag/testcore/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up testcore for local development.</p> <ol> <li> <p>Fork the testcore repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/testcore.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv testcore\n$ cd testcore/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 testcore tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/alexevag/testcore/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"ethopy/","title":"ethopy module","text":""},{"location":"experiment/","title":"Core Experiment module","text":""},{"location":"experiment/#ethopy.core.Experiment.ExperimentClass","title":"<code> ExperimentClass        </code>","text":"<p>Parent Experiment </p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>class ExperimentClass:\n    \"\"\"  Parent Experiment \"\"\"\n    curr_state, curr_trial, total_reward, cur_block, flip_count, states, stim, sync = '', 0, 0, 0, 0, dict(), False, False\n    un_choices, blocks, iter, curr_cond, block_h, stims, response, resp_ready = [], [], [], dict(), [], dict(), [], False\n    required_fields, default_key, conditions, cond_tables, quit, running, cur_block_sz = [], dict(), [], [], False, False, 0\n\n    # move from State to State using a template method.\n    class StateMachine:\n        \"\"\"  STATE MACHINE \"\"\"\n        def __init__(self, states):\n            self.states = states\n            self.futureState = states['Entry']\n            self.currentState = states['Entry']\n            self.exitState = states['Exit']\n\n        # # # # Main state loop # # # # #\n        def run(self):\n            while self.futureState != self.exitState:\n                if self.currentState != self.futureState:\n                    self.currentState.exit()\n                    self.currentState = self.futureState\n                    self.currentState.entry()\n                self.currentState.run()\n                self.futureState = self.states[self.currentState.next()]\n            self.currentState.exit()\n            self.exitState.run()\n\n    def setup(self, logger, BehaviorClass, session_params):\n        self.running = False\n        self.conditions, self.iter, self.quit, self.curr_cond, self.block_h, self.stims, self.curr_trial, self.cur_block_sz = [], [], False, dict(), [], dict(),0, 0\n        if \"setup_conf_idx\" not in self.default_key: self.default_key[\"setup_conf_idx\"] = 0\n        self.params = {**self.default_key, **session_params}\n        self.logger = logger\n        self.logger.log_session({**self.default_key, **session_params, 'experiment_type': self.cond_tables[0]},\n                                log_protocol=True)\n        self.beh = BehaviorClass()\n        self.beh.setup(self)\n        self.interface = self.beh.interface\n        self.session_timer = Timer()\n        np.random.seed(0)   # fix random seed for repeatability, it can be overidden in the conf file\n\n    def start(self):\n        states = dict()\n        for state in self.__class__.__subclasses__():  # Initialize states\n            states.update({state().__class__.__name__: state(self)})\n        state_control = self.StateMachine(states)\n        self.interface.set_running_state(True)\n        state_control.run()\n\n    def stop(self):\n        self.stim.exit()\n        self.interface.release()\n        self.beh.exit()\n        self.logger.ping(0)\n        if self.sync:\n            while self.interface.is_recording():\n                print('Waiting for recording to end...')\n                time.sleep(1)\n        self.logger.closeDatasets()\n        self.running = False\n\n    def is_stopped(self):\n        self.quit = self.quit or self.logger.setup_status in ['stop', 'exit']\n        if self.quit and self.logger.setup_status not in ['stop', 'exit']:\n            self.logger.update_setup_info({'status': 'stop'})\n        if self.quit: self.running = False\n        return self.quit\n\n    def make_conditions(self, stim_class, conditions, stim_periods=None):\n        # get stimulus class name\n        stim_name = stim_class.name()\n        if stim_name not in self.stims:\n            stim_class.init(self)\n            self.stims[stim_name] = stim_class\n        conditions.update({'stimulus_class': stim_name})\n\n        # Create conditions with permutation of variables\n        if not stim_periods:\n            conditions = self.stims[stim_name].make_conditions(factorize(conditions))\n        else:\n            cond = {}\n            for i in range(len(stim_periods)):\n                cond[stim_periods[i]] = self.stims[stim_name].make_conditions(conditions=factorize(conditions[stim_periods[i]]))\n                conditions[stim_periods[i]] = []\n            all_cond = [cond[stim_periods[i]] for i in range(len(stim_periods))]\n            for comb in list(itertools.product(*all_cond)):\n                for i in range(len(stim_periods)): conditions[stim_periods[i]].append(comb[i])\n            conditions = factorize(conditions)\n        conditions = self.log_conditions(**self.beh.make_conditions(conditions))\n\n        # Verify all required fields are set\n        for cond in conditions:\n            assert np.all([field in cond for field in self.required_fields])\n            cond.update({**self.default_key, **self.params, **cond, 'experiment_class': self.cond_tables[0]})\n\n        # Generate correct table name and Log conditions\n        cond_tables = ['Condition.' + table for table in self.cond_tables]\n        conditions = self.log_conditions(conditions, condition_tables=['Condition'] + cond_tables)\n        return conditions\n\n    def push_conditions(self, conditions):\n        self.conditions = conditions\n        resp_cond = self.params['resp_cond'] if 'resp_cond' in self.params else 'response_port'\n        self.blocks = np.array([cond['difficulty'] for cond in self.conditions])\n        if np.all([resp_cond in cond for cond in conditions]):\n            self.choices = np.array([make_hash([d[resp_cond], d['difficulty']]) for d in conditions])\n            self.un_choices, un_idx = np.unique(self.choices, axis=0, return_index=True)\n            self.un_blocks = self.blocks[un_idx]\n        # select random condition for first trial initialization\n        self.cur_block = min(self.blocks)\n        self.curr_cond = np.random.choice([i for (i, v) in zip(self.conditions, self.blocks == self.cur_block) if v])\n\n    def prepare_trial(self):\n        old_cond = self.curr_cond\n        self._get_new_cond()\n\n        if not self.curr_cond or self.logger.thread_end.is_set():\n            self.quit = True\n            return\n        if 'stimulus_class' not in old_cond or self.curr_trial == 0 \\\n                or old_cond['stimulus_class'] != self.curr_cond['stimulus_class']:\n            if 'stimulus_class' in old_cond and self.curr_trial != 0: self.stim.exit()\n            self.stim = self.stims[self.curr_cond['stimulus_class']]\n            print('setting up stimulus')\n            self.stim.setup()\n            print('done')\n        self.curr_trial += 1\n        self.logger.update_trial_idx(self.curr_trial)\n        self.trial_start = self.logger.logger_timer.elapsed_time()\n        self.logger.log('Trial', dict(cond_hash=self.curr_cond['cond_hash'], time=self.trial_start), priority=3)\n        if not self.running:\n            self.running = True\n\n    def name(self): return type(self).__name__\n\n    def log_conditions(self, conditions, condition_tables=['Condition'], schema='experiment', hsh='cond_hash', priority=2):\n        fields_key, hash_dict = list(), dict()\n        for ctable in condition_tables:\n            table = rgetattr(eval(schema), ctable)\n            fields_key += list(table().heading.names)\n        for cond in conditions:\n            insert_priority = priority\n            key = {sel_key: cond[sel_key] for sel_key in fields_key if sel_key != hsh and sel_key in cond}  # find all dependant fields and generate hash\n            cond.update({hsh: make_hash(key)})\n            hash_dict[cond[hsh]] = cond[hsh]\n            for ctable in condition_tables:  # insert dependant condition tables\n                core = [field for field in rgetattr(eval(schema), ctable).primary_key if field != hsh]\n                fields = [field for field in rgetattr(eval(schema), ctable).heading.names]\n                if not np.all([np.any(np.array(k) == list(cond.keys())) for k in fields]):\n                    #if self.logger.manual_run: print('skipping ', ctable)\n                    continue  # only insert complete tuples\n                if core and hasattr(cond[core[0]], '__iter__'):\n                    for idx, pcond in enumerate(cond[core[0]]):\n                        cond_key = {k: cond[k] if type(cond[k]) in [int, float, str] else cond[k][idx] for k in fields}\n                        self.logger.put(table=ctable, tuple=cond_key, schema=schema, priority=insert_priority)\n                else: self.logger.put(table=ctable, tuple=cond.copy(), schema=schema, priority=insert_priority)\n                insert_priority += 1\n        return conditions\n\n    def _anti_bias(self, choice_h, un_choices):\n        choice_h = np.array([make_hash(c) for c in choice_h[-self.curr_cond['bias_window']:]])\n        if len(choice_h) &lt; self.curr_cond['bias_window']: choice_h = self.choices\n        fixed_p = 1 - np.array([np.mean(choice_h == un) for un in un_choices])\n        if sum(fixed_p) == 0:  fixed_p = np.ones(np.shape(fixed_p))\n        return np.random.choice(un_choices, 1, p=fixed_p/sum(fixed_p))\n\n    def _get_performance(self):\n        idx = np.logical_or(~np.isnan(self.beh.reward_history), ~np.isnan(self.beh.punish_history))  # select valid\n        rew_h = np.asarray(self.beh.reward_history); rew_h = rew_h[idx]\n        choice_h = np.int64(np.asarray(self.beh.choice_history)[idx])\n        perf = np.nan\n        window = self.curr_cond['staircase_window']\n        if self.curr_cond['metric'] == 'accuracy':\n            perf = np.nanmean(np.greater(rew_h[-window:], 0))\n        elif self.curr_cond['metric'] == 'dprime':\n            y_true = [c if r &gt; 0 else c % 2 + 1 for (c, r) in zip(choice_h[-window:], rew_h[-window:])]\n            if len(np.unique(y_true)) &gt; 1:\n                perf = np.sqrt(2) * stats.norm.ppf(roc_auc_score(y_true, np.array(choice_h[-window:])))\n            if self.logger.manual_run:\n                print('perf: ', perf, ' accuracy: ', np.nanmean(np.greater(rew_h[-window:], 0)))\n        else:\n            print('Performance method not implemented!')\n            self.quit = True\n        choice_h = [[c, d] for c, d in zip(choice_h, np.asarray(self.block_h)[idx])]\n        return perf, choice_h\n\n    def _get_new_cond(self):\n        \"\"\" Get curr condition &amp; create random block of all conditions \"\"\"\n        if self.curr_cond['trial_selection'] == 'fixed':\n            self.curr_cond = [] if len(self.conditions) == 0 else self.conditions.pop()\n        elif self.curr_cond['trial_selection'] == 'block':\n            if np.size(self.iter) == 0: self.iter = np.random.permutation(np.size(self.conditions))\n            cond = self.conditions[self.iter[0]]\n            self.iter = self.iter[1:]\n            self.curr_cond = cond\n        elif self.curr_cond['trial_selection'] == 'random':\n            self.curr_cond = np.random.choice(self.conditions)\n        elif self.curr_cond['trial_selection'] == 'staircase':\n            perf, choice_h = self._get_performance()\n            if np.size(self.beh.choice_history) and self.beh.choice_history[-1:][0] &gt; 0:\n                self.cur_block_sz += 1  # current block trial counter\n            if self.cur_block_sz &gt;= self.curr_cond['staircase_window']:\n                if perf &gt;= self.curr_cond['stair_up']:\n                    self.cur_block = self.curr_cond['next_up']\n                    self.cur_block_sz = 0\n                    self.logger.update_setup_info({'difficulty': self.cur_block})\n                elif perf &lt; self.curr_cond['stair_down']:\n                    self.cur_block = self.curr_cond['next_down']\n                    self.cur_block_sz = 0\n                    self.logger.update_setup_info({'difficulty': self.cur_block})\n            if self.curr_cond['antibias']:\n                anti_bias = self._anti_bias(choice_h, self.un_choices[self.un_blocks == self.cur_block])\n                condition_idx = np.logical_and(self.choices == anti_bias, self.blocks == self.cur_block)\n            else: condition_idx = self.blocks == self.cur_block\n            self.curr_cond = np.random.choice([i for (i, v) in zip(self.conditions, condition_idx) if v])\n            self.block_h.append(self.cur_block)\n        elif self.curr_cond['trial_selection'] == 'biased':\n            perf, choice_h = self._get_performance()\n            condition_idx = self.choices == self._anti_bias(choice_h, self.un_choices)\n            self.curr_cond = np.random.choice([i for (i, v) in zip(self.conditions, condition_idx) if v])\n        else:\n            print('Selection method not implemented!')\n            self.quit = True\n\n\n    @dataclass\n    class Block:\n        difficulty: int = field(compare=True, default=0, hash=True)\n        stair_up: float = field(compare=False, default=.7)\n        stair_down: float = field(compare=False, default=0.55)\n        next_up: int = field(compare=False, default=0)\n        next_down: int = field(compare=False, default=0)\n        staircase_window: int = field(compare=False, default=20)\n        bias_window: int = field(compare=False, default=5)\n        trial_selection: str = field(compare=False, default='fixed')\n        metric: str = field(compare=False, default='accuracy')\n        antibias: bool = field(compare=False, default=True)\n        noresponse_intertrial: bool = field(compare=False, default=True)\n        incremental_punishment: bool = field(compare=False, default=False)\n\n        def dict(self):\n            return self.__dict__\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.ExperimentClass.Block","title":"<code> Block        </code>  <code>dataclass</code>","text":"<p>Block(difficulty: int = 0, stair_up: float = 0.7, stair_down: float = 0.55, next_up: int = 0, next_down: int = 0, staircase_window: int = 20, bias_window: int = 5, trial_selection: str = 'fixed', metric: str = 'accuracy', antibias: bool = True, noresponse_intertrial: bool = True, incremental_punishment: bool = False)</p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>class Block:\n    difficulty: int = field(compare=True, default=0, hash=True)\n    stair_up: float = field(compare=False, default=.7)\n    stair_down: float = field(compare=False, default=0.55)\n    next_up: int = field(compare=False, default=0)\n    next_down: int = field(compare=False, default=0)\n    staircase_window: int = field(compare=False, default=20)\n    bias_window: int = field(compare=False, default=5)\n    trial_selection: str = field(compare=False, default='fixed')\n    metric: str = field(compare=False, default='accuracy')\n    antibias: bool = field(compare=False, default=True)\n    noresponse_intertrial: bool = field(compare=False, default=True)\n    incremental_punishment: bool = field(compare=False, default=False)\n\n    def dict(self):\n        return self.__dict__\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.ExperimentClass.StateMachine","title":"<code> StateMachine        </code>","text":"<p>STATE MACHINE </p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>class StateMachine:\n    \"\"\"  STATE MACHINE \"\"\"\n    def __init__(self, states):\n        self.states = states\n        self.futureState = states['Entry']\n        self.currentState = states['Entry']\n        self.exitState = states['Exit']\n\n    # # # # Main state loop # # # # #\n    def run(self):\n        while self.futureState != self.exitState:\n            if self.currentState != self.futureState:\n                self.currentState.exit()\n                self.currentState = self.futureState\n                self.currentState.entry()\n            self.currentState.run()\n            self.futureState = self.states[self.currentState.next()]\n        self.currentState.exit()\n        self.exitState.run()\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.State","title":"<code> State        </code>","text":"Source code in <code>ethopy/core/Experiment.py</code> <pre><code>class State:\n    state_timer, __shared_state = Timer(), {}\n\n    def __init__(self, parent=None):\n        self.__dict__ = self.__shared_state\n        if parent: self.__dict__.update(parent.__dict__)\n\n    def entry(self):\n        \"\"\"Entry transition method\"\"\"\n        pass\n\n    def run(self):\n        \"\"\"Main run command\"\"\"\n        pass\n\n    def next(self):\n        \"\"\"Exit transition method\"\"\"\n        assert 0, \"next not implemented\"\n\n    def exit(self):\n        \"\"\"Exit transition method\"\"\"\n        pass\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.State.entry","title":"<code>entry(self)</code>","text":"<p>Entry transition method</p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>def entry(self):\n    \"\"\"Entry transition method\"\"\"\n    pass\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.State.exit","title":"<code>exit(self)</code>","text":"<p>Exit transition method</p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>def exit(self):\n    \"\"\"Exit transition method\"\"\"\n    pass\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.State.next","title":"<code>next(self)</code>","text":"<p>Exit transition method</p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>def next(self):\n    \"\"\"Exit transition method\"\"\"\n    assert 0, \"next not implemented\"\n</code></pre>"},{"location":"experiment/#ethopy.core.Experiment.State.run","title":"<code>run(self)</code>","text":"<p>Main run command</p> Source code in <code>ethopy/core/Experiment.py</code> <pre><code>def run(self):\n    \"\"\"Main run command\"\"\"\n    pass\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install EthoPy, run this command in your terminal:</p> <pre><code>pip install testcore\n</code></pre> <p>This is the preferred method to install EthoPy, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install EthoPy from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/alexevag/testcore\n</code></pre>"},{"location":"interface/","title":"Core Interface module","text":""},{"location":"interface/#ethopy.core.Interface.Port","title":"<code> Port        </code>  <code>dataclass</code>","text":"<p>Port(**kwargs)</p> Source code in <code>ethopy/core/Interface.py</code> <pre><code>class Port:\n    port: int = datafield(compare=True, default=0, hash=True)\n    type: str = datafield(compare=True, default='', hash=True)\n    ready: bool = datafield(compare=False, default=False)\n    reward: bool = datafield(compare=False, default=False)\n    response: bool = datafield(compare=False, default=False)\n    invert: bool = datafield(compare=False, default=False)\n\n    def __init__(self, **kwargs):\n        names = set([f.name for f in fields(self)])\n        for k, v in kwargs.items():\n            if k in names: setattr(self, k, v)\n</code></pre>"},{"location":"logger/","title":"Core Logger module","text":""},{"location":"logger/#ethopy.core.Logger.Logger","title":"<code> Logger        </code>","text":"Source code in <code>ethopy/core/Logger.py</code> <pre><code>class Logger:\n    DEFAULT_SOURCE_PATH = os.path.expanduser(\"~\") + \"/EthoPy_Files/\"\n    DEFAULT_TARGET_PATH = False\n\n    def __init__(self, protocol=False):\n\n        self.setup = socket.gethostname()\n        self.is_pi = self._check_if_raspberry_pi()\n\n        self.task_idx, self.protocol_path = self._parse_protocol(protocol)\n\n        self.manual_run = True if self.protocol_path else False\n\n        self.setup_status = \"running\" if self.manual_run else \"ready\"\n\n        self.writer = Writer\n        self.rec_fliptimes = True\n        self.trial_key = {'animal_id': 0, 'session': 1, 'trial_idx': 0}\n        self.setup_info = {}\n        self.datasets = {}\n        self.lock = False\n        self.queue = PriorityQueue()\n        self.ping_timer = Timer()\n        self.logger_timer = Timer()\n        self.total_reward = 0\n        self.curr_state = \"\"\n\n        # separate connection for internal communication\n        self.private_conn = dj.Connection(\n            dj.config[\"database.host\"],\n            dj.config[\"database.user\"],\n            dj.config[\"database.password\"],\n        )\n        self._schemata = self._initialize_schemata()\n\n        self.source_path = self.get_path(\"source_path\", self.DEFAULT_SOURCE_PATH)\n        self.target_path = self.get_path(\"target_path\", self.DEFAULT_TARGET_PATH)\n\n        self.thread_end, self.thread_lock = threading.Event(), threading.Lock()\n        self.inserter_thread = threading.Thread(target=self.inserter)\n        self.getter_thread = threading.Thread(target=self._sync_setup_info)\n        self.inserter_thread.start()\n        self._log_setup(self.task_idx)\n        self.getter_thread.start()\n        self.logger_timer.start()\n\n    def _parse_protocol(self, protocol):\n        if protocol and protocol.isdigit():\n            print(\"int protocol\", int(protocol), self._find_protocol_path(int(protocol)))\n            return int(protocol), self._find_protocol_path(int(protocol))\n        elif protocol and isinstance(protocol, str):\n            print(\"_validate_protocol protocol\", protocol)\n            return None, protocol\n        else:\n            return None, None\n\n    def update_protocol(self):\n        \"\"\"\n        This method updates the protocol path based on the current setup.\n\n        If the run is manual, it checks if the protocol file exists at the specified path.\n        If the file does not exist, it prints an error message and returns False.\n\n        If the run is not manual, it fetches the task index from the setup info.\n        It then checks if there is a task with this index in the experiment's Task table.\n        If there is no such task, it returns False.\n        Otherwise, it fetches the protocol associated with this task and updates the protocol path.\n\n        Returns:\n            bool: True if the protocol path was successfully updated, False otherwise.\n        \"\"\"\n        if self.manual_run:\n            if not os.path.isfile(self.protocol_path):\n                print(f\"Protocol file {self.protocol_path} not found!\")\n                return False\n        else:\n            task_idx = self.get_setup_info('task_idx')\n            if not len(experiment.Task() &amp; dict(task_idx=task_idx)) &gt; 0:\n                return False\n            protocol = (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1('protocol')\n            self.protocol_path = protocol\n        return True\n\n    @property\n    def protocol_path(self) -&gt; str:\n        \"\"\"\n        Get the protocol path.\n\n        Returns:\n            str: The protocol path.\n        \"\"\"\n        return self._protocol_path\n\n    @protocol_path.setter\n    def protocol_path(self, protocol_path: str):\n        \"\"\"\n        Set the protocol path. if protocol_path has only filename\n        set the protocol_path at the conf directory.\n\n        Args:\n            protocol_path (str): The protocol path.\n        \"\"\"\n\n        if protocol_path is not None:\n            path, filename = os.path.split(protocol_path)\n            print(path, filename)\n            if not path:\n                protocol_path = (\n                    str(pathlib.Path(__file__).parent.absolute()) + \"/../conf/\" + filename\n                )\n        self._protocol_path = protocol_path\n\n    def _find_protocol_path(self, task_idx=None):\n        \"\"\"find the protocol path from the task index\"\"\"\n        if task_idx:\n            return (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1(\"protocol\")\n        else:\n            return False\n\n    def _initialize_schemata(self) -&gt; Dict[str, dj.VirtualModule]:\n        return {\n            schema: dj.create_virtual_module(\n                schema, value, connection=self.private_conn\n            )\n            for schema, value in SCHEMATA.items()\n        }\n\n    def _check_if_raspberry_pi(self) -&gt; bool:\n        system = platform.uname()\n        return (\n            system.machine.startswith(\"arm\") or system.machine == \"aarch64\"\n            if system.system == \"Linux\"\n            else False\n        )\n\n    def get_path(self, path_key: str, default_path: str) -&gt; str:\n        \"\"\"\n        Get the path from the configuration or create a new directory at the default path.\n\n        Args:\n        path_key (str): The key to look up in the configuration.\n        default_path (str): The path to use if the key is not in the configuration.\n\n        Returns:\n        str: The path from the configuration or the default path.\n        \"\"\"\n        path = config.get(path_key, default_path)\n        if path:\n            os.makedirs(path, exist_ok=True)\n            print(f\"Setting storage directory: {path}\")\n        return path\n\n    def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set up additional schema.\n\n        Args:\n        extra_schema (Dict[str, Any]): The additional schema to set up.\n        \"\"\"\n        for schema, value in extra_schema.items():\n            globals()[schema] = dj.create_virtual_module(\n                schema, value, create_tables=True, create_schema=True\n            )\n            self._schemata.update(\n                {\n                    schema: dj.create_virtual_module(\n                        schema, value, connection=self.private_conn\n                    )\n                }\n            )\n\n    def put(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Put an item in the queue.\n\n        Parameters:\n        **kwargs (Any): The item to put in the queue.\n        \"\"\"\n        item = PrioritizedItem(**kwargs)\n        self.queue.put(item)\n        if not item.block:\n            self.queue.task_done()\n        else:\n            self.queue.join()\n\n    def insert_item(self, item, table):\n        \"\"\"\n        Inserts an item into the specified table.\n\n        Args:\n            item: The item to be inserted.\n            table: The table to insert the item into.\n\n        Returns:\n            None\n        \"\"\"\n        table.insert1(\n            item.tuple,\n            ignore_extra_fields=item.ignore_extra_fields,\n            skip_duplicates=False if item.replace else True,\n            replace=item.replace,\n        )\n\n    def validate_item(self, item, table):\n        \"\"\"\n        Validates an item against a table.\n        \"\"\"\n        if item.validate:  # validate tuple exists in database\n            key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n            if \"status\" in item.tuple.keys():\n                key[\"status\"] = item.tuple[\"status\"]\n            while not len(table &amp; key) &gt; 0:\n                time.sleep(0.5)\n\n    def handle_error(self, item, table, e, thread_end, queue):\n        \"\"\"\n        Handles an error by logging the error message and add the item again in the queue\n        and re-trying again later.\n\n        Parameters:\n        item : Description of parameter `item`.\n        table : Description of parameter `table`.\n        e (Exception): The exception that was raised.\n        thread_end : Description of parameter `thread_end`.\n        queue : Description of parameter `queue`.\n        \"\"\"\n        str_error = f\"Failed to insert:\\n{item.tuple}\\n in {table}\\n With error:\\n{e}\"\n        if item.error:\n            thread_end.set()\n            raise str_error + \"\\nSecond time...\"\n        print(str_error+\"\\nWill retry later\")\n        item.error = True\n        item.priority = item.priority + 2\n        queue.put(item)\n\n    def inserter(self):\n        \"\"\"\n        This method continuously inserts items from the queue into their respective tables in\n        the database.\n\n        It runs in a loop until the thread_end event is set. In each iteration, it checks if\n        the queue is empty.\n        If it is, it sleeps for 0.5 seconds and then continues to the next iteration.\n        If the queue is not empty.\n        it gets an item from the queue, acquires the thread lock, and tries to insert\n        the item into its table.\n        If an error occurs during the insertion, it handles the error.\n        After the insertion, it releases the thread lock.\n        If the item was marked to block, it marks the task as done.\n\n        Returns:\n            None\n        \"\"\"\n        while not self.thread_end.is_set():\n            if self.queue.empty():\n                time.sleep(0.5)\n                continue\n            item = self.queue.get()\n            table = rgetattr(self._schemata[item.schema], item.table)\n            self.thread_lock.acquire()\n            try:\n                self.insert_item(item, table)\n                self.validate_item(item, table)\n            except ValueError as e:\n                if item.error:\n                    self.thread_end.set()\n                    raise\n                self.handle_error(item, table, e, self.thread_end, self.queue)\n            self.thread_lock.release()\n            if item.block:\n                self.queue.task_done()\n\n    def _sync_setup_info(self):\n        \"\"\"\n        This method continuously updates the setup information and status from the experiment\n        database.\n\n        It runs in a loop until the thread_end event is set. In each iteration, it acquires the thread lock,\n        fetches the setup information from the Control table in the experiment database, releases the thread lock,\n        and updates the setup status. It then sleeps for 1 second before the next iteration.\n\n        Returns:\n            None\n        \"\"\"\n        while not self.thread_end.is_set():\n            self.thread_lock.acquire()\n            self.setup_info = (\n                self._schemata[\"experiment\"].Control() &amp; dict(setup=self.setup)\n            ).fetch1()\n            self.thread_lock.release()\n            self.setup_status = self.setup_info[\"status\"]\n            time.sleep(1)  # update once a second\n\n    def log(self, table, data=None, **kwargs):\n        \"\"\"\n        This method logs the given data into the specified table in the experiment database.\n\n        It first gets the elapsed time from the logger timer and adds it to the data dictionary.\n        It then puts the data into the specified table. If the manual_run flag is set and the\n        table is \"Trial.StateOnset\",\n        it prints the state.\n\n        Args:\n            table (str): The name of the table in the experiment database.\n            data (dict, optional): The data to be logged. Defaults to an empty dictionary.\n            **kwargs: Additional keyword arguments to be passed to the put method.\n\n        Returns:\n            float: The elapsed time from the logger timer.\n        \"\"\"\n        tmst = self.logger_timer.elapsed_time()\n        data = data or {}\n        self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n        if self.manual_run and table == \"Trial.StateOnset\":\n            print(\"State: \", data[\"state\"])\n        return tmst\n\n    def _log_setup(self, task=None):\n        \"\"\"\n        This method logs the setup information into the Control table in the experiment database.\n\n        It first fetches the control information for the current setup. If no control information is found,\n        it creates a new dictionary with the setup information. If a task is provided and it is an integer,\n        it adds the task index to the key. It then adds the IP and status information to the key.\n\n        The method finally puts the key into the Control table, replacing any existing entry with the same key.\n        It blocks until the operation is complete and validates the operation.\n\n        Args:\n            task (int, optional): The task index. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        rel = experiment.Control() &amp; dict(setup=self.setup)\n        key = rel.fetch1() if np.size(rel.fetch()) else dict(setup=self.setup)\n        if task and isinstance(task, int):\n            key[\"task_idx\"] = task\n        key = {**key, \"ip\": self.get_ip(), \"status\": self.setup_status}\n        self.put(\n            table=\"Control\",\n            tuple=key,\n            replace=True,\n            priority=1,\n            block=True,\n            validate=True,\n        )\n\n    def _get_last_session(self):\n        \"\"\"\n        This method fetches the last session for a given animal_id from the experiment.Session.\n\n        It first fetches all sessions for the given animal_id. If no sessions are found,\n        it returns 0.\n        If sessions are found, it returns the maximum session number, which corresponds to\n        the last session.\n\n        Returns:\n            int: The last session number or 0 if no sessions are found.\n        \"\"\"\n        last_sessions = (\n            experiment.Session() &amp; dict(animal_id=self.get_setup_info(\"animal_id\"))\n        ).fetch(\"session\")\n        return 0 if np.size(last_sessions) == 0 else np.max(last_sessions)\n\n    def log_session(self, params: Dict[str, Any], log_protocol: bool = False) -&gt; None:\n        \"\"\"\n        Logs a session with the given parameters and optionally logs the protocol.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n            log_protocol (bool): Whether to log the protocol information.\n        \"\"\"\n        self._initialize_session()\n        session_key = self._create_session_key(params)\n        self._log_session_entry(session_key)\n\n        if log_protocol:\n            self._log_protocol()\n\n        self._log_configuration()\n        self._log_additional_configurations(params)\n        self._set_setup_status(params)\n\n        self.logger_timer.start()  # Start session time\n\n    def _initialize_session(self) -&gt; None:\n        \"\"\"\n        Initializes session attributes.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        self.total_reward = 0\n        self.trial_key = {\n            \"animal_id\": self.get_setup_info(\"animal_id\"),\n            \"trial_idx\": 0,\n            \"session\": self._get_last_session() + 1,\n        }\n\n    def _create_session_key(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Creates a session key by merging trial key with session parameters.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n\n        Returns:\n            Dict[str, Any]: The complete session key.\n        \"\"\"\n        return {\n            **self.trial_key,\n            **params,\n            \"setup\": self.setup,\n            \"user_name\": params.get(\"user_name\", \"bot\"),\n        }\n\n    def _log_session_entry(self, session_key: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Logs the session entry to the database.\n\n        Args:\n            session_key (Dict[str, Any]): The session key to log.\n        \"\"\"\n        if self.manual_run:\n            print(\"Logging Session:\")\n            pprint.pprint(session_key)\n        self.put(\n            table=\"Session\", tuple=session_key, priority=1, validate=True, block=True\n        )\n\n    def _log_protocol(self) -&gt; None:\n        \"\"\"\n        Logs the protocol information to the database.\n        \"\"\"\n        pr_name = self.protocol_path\n        pr_file = np.fromfile(self.protocol_path, dtype=np.int8)\n        try:\n            git_hash = (\n                subprocess.check_output([\"git\", \"rev-parse\", \"--short\", \"HEAD\"])\n                .decode(\"ascii\")\n                .strip()\n            )\n        except subprocess.CalledProcessError:\n            git_hash = f\"pip version {VERSION}\"\n\n        self.put(\n            table=\"Session.Protocol\",\n            tuple={\n                **self.trial_key,\n                \"protocol_name\": pr_name,\n                \"protocol_file\": pr_file,\n                \"git_hash\": git_hash,\n            },\n        )\n\n    def _log_configuration(self) -&gt; None:\n        \"\"\"\n        Logs the basic configuration to the database.\n        \"\"\"\n        self.put(\n            table=\"Configuration\",\n            tuple=self.trial_key,\n            schema=\"behavior\",\n            priority=2,\n            validate=True,\n            block=True,\n        )\n        self.put(\n            table=\"Configuration\",\n            tuple=self.trial_key,\n            schema=\"stimulus\",\n            priority=2,\n            validate=True,\n            block=True,\n        )\n\n    def _log_additional_configurations(self, params: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Logs additional configurations like ports, screens, balls, and speakers.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        configurations = [\n            (\"Port\", \"behavior\"),\n            (\"Screen\", \"stimulus\"),\n            (\"Ball\", \"behavior\"),\n            (\"Speaker\", \"stimulus\"),\n        ]\n        for config_type, schema in configurations:\n            self._log_individual_configuration(params, config_type, schema)\n\n    def _log_individual_configuration(\n        self, params: Dict[str, Any], config_type: str, schema: str\n    ) -&gt; None:\n        \"\"\"\n        Logs individual configuration type to the database.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n            config_type (str): The type of configuration (e.g., Port, Screen).\n            schema (str): The schema for the configuration.\n        \"\"\"\n        configuration_data = (\n            getattr(experiment.SetupConfiguration, config_type)\n            &amp; {\"setup_conf_idx\": params[\"setup_conf_idx\"]}\n        ).fetch(as_dict=True)\n        for conf in configuration_data:\n            self.put(\n                table=f\"Configuration.{config_type}\",\n                tuple={**conf, **self.trial_key},\n                schema=schema,\n            )\n\n    def _set_setup_status(self, params: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Sets the setup status and updates setup information.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        key = {\n            \"session\": self.trial_key[\"session\"],\n            \"trials\": 0,\n            \"total_liquid\": 0,\n            \"difficulty\": 1,\n            \"state\": \"\",\n        }\n        # if in the start_time is defined in the configuration use this\n        # otherwise use the Control table\n        if \"start_time\" in params:\n\n            def tdelta(t):\n                return datetime.strptime(t, \"%H:%M:%S\") - datetime.strptime(\n                    \"00:00:00\", \"%H:%M:%S\"\n                )\n\n            key.update(\n                {\n                    \"start_time\": str(tdelta(params[\"start_time\"])),\n                    \"stop_time\": str(tdelta(params[\"stop_time\"])),\n                }\n            )\n\n        self.update_setup_info({**key, \"status\": self.setup_info[\"status\"]})\n\n    def update_setup_info(self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        This method updates the setup information with the provided info and key.\n\n        It first fetches the existing setup information from the experiment's Control table,\n        then updates it with the provided info. If 'status' is in the provided info, it blocks\n        and validates the update operation.\n\n        Args:\n            info (dict): The information to update the setup with.\n            key (dict, optional): Additional keys to fetch the setup information with.\n            Defaults to an empty dict.\n\n        Side Effects:\n            Updates the setup_info attribute with the new setup information.\n            Updates the setup_status attribute with the new status.\n        \"\"\"\n        if key is None:\n            key = dict()\n        self.setup_info = {\n            **(experiment.Control() &amp; {**{\"setup\": self.setup}, **key}).fetch1(),\n            **info,\n        }\n        block = True if \"status\" in info else False\n        self.put(\n            table=\"Control\",\n            tuple=self.setup_info,\n            replace=True,\n            priority=1,\n            block=block,\n            validate=block,\n        )\n        self.setup_status = self.setup_info[\"status\"]\n\n    def get_setup_info(self, field):\n        return (experiment.Control() &amp; dict(setup=self.setup)).fetch1(field)\n\n    def get(\n        self,\n        schema: str = \"experiment\",\n        table: str = \"Control\",\n        fields: str = \"\",\n        key: Dict[str, Any] = dict(),\n        **kwargs: Any\n    ) -&gt; Any:\n        \"\"\"\n        Fetches data from a specified table in a schema.\n\n        Parameters:\n        schema (str): The schema to fetch data from. Defaults to \"experiment\".\n        table (str): The table to fetch data from. Defaults to \"Control\".\n        fields (str): The fields to fetch. Defaults to \"\".\n        key (dict): The key used to fetch data. Defaults to an empty dict.\n        **kwargs: Additional keyword arguments.\n\n        Returns:\n        The fetched data.\n        \"\"\"\n        _table = rgetattr(eval(schema), table)\n        return (_table() &amp; key).fetch(*fields, **kwargs)\n\n    def update_trial_idx(self, trial_idx):\n        self.trial_key[\"trial_idx\"] = trial_idx\n\n    def ping(self, period=5000):\n        if (\n            self.ping_timer.elapsed_time() &gt;= period\n        ):  # occasionally update control table\n            self.ping_timer.start()\n            self.update_setup_info(\n                {\n                    \"last_ping\": str(datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")),\n                    \"queue_size\": self.queue.qsize(),\n                    \"trials\": self.trial_key[\"trial_idx\"],\n                    \"total_liquid\": self.total_reward,\n                    \"state\": self.curr_state,\n                }\n            )\n\n    def cleanup(self):\n        while not self.queue.empty():\n            print(\"Waiting for empty queue... qsize: %d\" % self.queue.qsize())\n            time.sleep(1)\n        self.thread_end.set()\n\n    def createDataset(\n        self,\n        dataset_name: str,\n        dataset_type: type,\n        filename: Optional[str] = None,\n        log: Optional[bool] = True,\n    ) -&gt; Any:\n        \"\"\"\n        Create a dataset and return the dataset object.\n        Args:\n            target_path (str): The target path for the dataset.\n            dataset_name (str): The name of the dataset.\n            dataset_type (type): The datatype of the dataset.\n            filename (str, optional): The filename for the h5 file. If not provided,\n            a default filename will be generated based on the dataset name, animal ID,\n            session, and current timestamp.\n            log (bool, optional): If True call the log_recording\n        Returns:\n            Tuple[str, Any]: A tuple containing the filename and the dataset object.\n        \"\"\"\n        folder = (\n            f\"Recordings/{self.trial_key['animal_id']}\" f\"_{self.trial_key['session']}/\"\n        )\n        path = self.source_path + folder\n        if not os.path.isdir(path):\n            os.makedirs(path)  # create path if necessary\n\n        if not os.path.isdir(self.target_path):\n            print(\"No target directory set! Autocopying will not work.\")\n            target_path = None\n        else:\n            target_path = self.target_path + folder\n            if not os.path.isdir(target_path):\n                os.makedirs(target_path)\n\n        # Generate filename if not provided\n        if filename is None:\n            filename = \"%s_%d_%d_%s.h5\" % (\n                dataset_name,\n                self.trial_key[\"animal_id\"],\n                self.trial_key[\"session\"],\n                datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\"),\n            )\n\n        if filename not in self.datasets:\n            # create h5 file if not exists\n            self.datasets[filename] = self.writer(path + filename, target_path)\n\n        # create new dataset in the h5 files\n        self.datasets[filename].createDataset(\n            dataset_name, shape=(1,), dtype=dataset_type\n        )\n\n        if log:\n            rec_key = dict(\n                rec_aim=dataset_name,\n                software=\"EthoPy\",\n                version=VERSION,\n                filename=filename,\n                source_path=path,\n                target_path=target_path,\n            )\n            self.log_recording(rec_key)\n\n        return self.datasets[filename]\n\n    def log_recording(self, rec_key):\n        recs = self.get(\n            schema=\"recording\",\n            table=\"Recording\",\n            key=self.trial_key,\n            fields=[\"rec_idx\"],\n        )\n        rec_idx = 1 if not recs else max(recs) + 1\n        self.log(\"Recording\", data={**rec_key, \"rec_idx\": rec_idx}, schema=\"recording\")\n\n    def closeDatasets(self):\n        for dataset in self.datasets:\n            self.datasets[dataset].exit()\n\n    @staticmethod\n    def get_ip():\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        try:\n            s.connect((\"8.8.8.8\", 80))\n            ip = s.getsockname()[0]\n        except Exception:\n            ip = \"127.0.0.1\"\n        finally:\n            s.close()\n        return ip\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.protocol_path","title":"<code>protocol_path: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the protocol path.</p> <p>Returns:</p> Type Description <code>str</code> <p>The protocol path.</p>"},{"location":"logger/#ethopy.core.Logger.Logger.createDataset","title":"<code>createDataset(self, dataset_name, dataset_type, filename=None, log=True)</code>","text":"<p>Create a dataset and return the dataset object.</p> <p>Parameters:</p> Name Type Description Default <code>target_path</code> <code>str</code> <p>The target path for the dataset.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>dataset_type</code> <code>type</code> <p>The datatype of the dataset.</p> required <code>filename</code> <code>str</code> <p>The filename for the h5 file. If not provided,</p> <code>None</code> <code>log</code> <code>bool</code> <p>If True call the log_recording</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[str, Any]</code> <p>A tuple containing the filename and the dataset object.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def createDataset(\n    self,\n    dataset_name: str,\n    dataset_type: type,\n    filename: Optional[str] = None,\n    log: Optional[bool] = True,\n) -&gt; Any:\n    \"\"\"\n    Create a dataset and return the dataset object.\n    Args:\n        target_path (str): The target path for the dataset.\n        dataset_name (str): The name of the dataset.\n        dataset_type (type): The datatype of the dataset.\n        filename (str, optional): The filename for the h5 file. If not provided,\n        a default filename will be generated based on the dataset name, animal ID,\n        session, and current timestamp.\n        log (bool, optional): If True call the log_recording\n    Returns:\n        Tuple[str, Any]: A tuple containing the filename and the dataset object.\n    \"\"\"\n    folder = (\n        f\"Recordings/{self.trial_key['animal_id']}\" f\"_{self.trial_key['session']}/\"\n    )\n    path = self.source_path + folder\n    if not os.path.isdir(path):\n        os.makedirs(path)  # create path if necessary\n\n    if not os.path.isdir(self.target_path):\n        print(\"No target directory set! Autocopying will not work.\")\n        target_path = None\n    else:\n        target_path = self.target_path + folder\n        if not os.path.isdir(target_path):\n            os.makedirs(target_path)\n\n    # Generate filename if not provided\n    if filename is None:\n        filename = \"%s_%d_%d_%s.h5\" % (\n            dataset_name,\n            self.trial_key[\"animal_id\"],\n            self.trial_key[\"session\"],\n            datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\"),\n        )\n\n    if filename not in self.datasets:\n        # create h5 file if not exists\n        self.datasets[filename] = self.writer(path + filename, target_path)\n\n    # create new dataset in the h5 files\n    self.datasets[filename].createDataset(\n        dataset_name, shape=(1,), dtype=dataset_type\n    )\n\n    if log:\n        rec_key = dict(\n            rec_aim=dataset_name,\n            software=\"EthoPy\",\n            version=VERSION,\n            filename=filename,\n            source_path=path,\n            target_path=target_path,\n        )\n        self.log_recording(rec_key)\n\n    return self.datasets[filename]\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.get","title":"<code>get(self, schema='experiment', table='Control', fields='', key={}, **kwargs)</code>","text":"<p>Fetches data from a specified table in a schema.</p> <p>schema (str): The schema to fetch data from. Defaults to \"experiment\". table (str): The table to fetch data from. Defaults to \"Control\". fields (str): The fields to fetch. Defaults to \"\". key (dict): The key used to fetch data. Defaults to an empty dict. **kwargs: Additional keyword arguments.</p> <p>The fetched data.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def get(\n    self,\n    schema: str = \"experiment\",\n    table: str = \"Control\",\n    fields: str = \"\",\n    key: Dict[str, Any] = dict(),\n    **kwargs: Any\n) -&gt; Any:\n    \"\"\"\n    Fetches data from a specified table in a schema.\n\n    Parameters:\n    schema (str): The schema to fetch data from. Defaults to \"experiment\".\n    table (str): The table to fetch data from. Defaults to \"Control\".\n    fields (str): The fields to fetch. Defaults to \"\".\n    key (dict): The key used to fetch data. Defaults to an empty dict.\n    **kwargs: Additional keyword arguments.\n\n    Returns:\n    The fetched data.\n    \"\"\"\n    _table = rgetattr(eval(schema), table)\n    return (_table() &amp; key).fetch(*fields, **kwargs)\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.get_path","title":"<code>get_path(self, path_key, default_path)</code>","text":"<p>Get the path from the configuration or create a new directory at the default path.</p> <p>path_key (str): The key to look up in the configuration. default_path (str): The path to use if the key is not in the configuration.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def get_path(self, path_key: str, default_path: str) -&gt; str:\n    \"\"\"\n    Get the path from the configuration or create a new directory at the default path.\n\n    Args:\n    path_key (str): The key to look up in the configuration.\n    default_path (str): The path to use if the key is not in the configuration.\n\n    Returns:\n    str: The path from the configuration or the default path.\n    \"\"\"\n    path = config.get(path_key, default_path)\n    if path:\n        os.makedirs(path, exist_ok=True)\n        print(f\"Setting storage directory: {path}\")\n    return path\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.handle_error","title":"<code>handle_error(self, item, table, e, thread_end, queue)</code>","text":"<p>Handles an error by logging the error message and add the item again in the queue and re-trying again later.</p> <p>item : Description of parameter <code>item</code>. table : Description of parameter <code>table</code>. e (Exception): The exception that was raised. thread_end : Description of parameter <code>thread_end</code>. queue : Description of parameter <code>queue</code>.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def handle_error(self, item, table, e, thread_end, queue):\n    \"\"\"\n    Handles an error by logging the error message and add the item again in the queue\n    and re-trying again later.\n\n    Parameters:\n    item : Description of parameter `item`.\n    table : Description of parameter `table`.\n    e (Exception): The exception that was raised.\n    thread_end : Description of parameter `thread_end`.\n    queue : Description of parameter `queue`.\n    \"\"\"\n    str_error = f\"Failed to insert:\\n{item.tuple}\\n in {table}\\n With error:\\n{e}\"\n    if item.error:\n        thread_end.set()\n        raise str_error + \"\\nSecond time...\"\n    print(str_error+\"\\nWill retry later\")\n    item.error = True\n    item.priority = item.priority + 2\n    queue.put(item)\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.insert_item","title":"<code>insert_item(self, item, table)</code>","text":"<p>Inserts an item into the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The item to be inserted.</p> required <code>table</code> <p>The table to insert the item into.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def insert_item(self, item, table):\n    \"\"\"\n    Inserts an item into the specified table.\n\n    Args:\n        item: The item to be inserted.\n        table: The table to insert the item into.\n\n    Returns:\n        None\n    \"\"\"\n    table.insert1(\n        item.tuple,\n        ignore_extra_fields=item.ignore_extra_fields,\n        skip_duplicates=False if item.replace else True,\n        replace=item.replace,\n    )\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.inserter","title":"<code>inserter(self)</code>","text":"<p>This method continuously inserts items from the queue into their respective tables in the database.</p> <p>It runs in a loop until the thread_end event is set. In each iteration, it checks if the queue is empty. If it is, it sleeps for 0.5 seconds and then continues to the next iteration. If the queue is not empty. it gets an item from the queue, acquires the thread lock, and tries to insert the item into its table. If an error occurs during the insertion, it handles the error. After the insertion, it releases the thread lock. If the item was marked to block, it marks the task as done.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def inserter(self):\n    \"\"\"\n    This method continuously inserts items from the queue into their respective tables in\n    the database.\n\n    It runs in a loop until the thread_end event is set. In each iteration, it checks if\n    the queue is empty.\n    If it is, it sleeps for 0.5 seconds and then continues to the next iteration.\n    If the queue is not empty.\n    it gets an item from the queue, acquires the thread lock, and tries to insert\n    the item into its table.\n    If an error occurs during the insertion, it handles the error.\n    After the insertion, it releases the thread lock.\n    If the item was marked to block, it marks the task as done.\n\n    Returns:\n        None\n    \"\"\"\n    while not self.thread_end.is_set():\n        if self.queue.empty():\n            time.sleep(0.5)\n            continue\n        item = self.queue.get()\n        table = rgetattr(self._schemata[item.schema], item.table)\n        self.thread_lock.acquire()\n        try:\n            self.insert_item(item, table)\n            self.validate_item(item, table)\n        except ValueError as e:\n            if item.error:\n                self.thread_end.set()\n                raise\n            self.handle_error(item, table, e, self.thread_end, self.queue)\n        self.thread_lock.release()\n        if item.block:\n            self.queue.task_done()\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.log","title":"<code>log(self, table, data=None, **kwargs)</code>","text":"<p>This method logs the given data into the specified table in the experiment database.</p> <p>It first gets the elapsed time from the logger timer and adds it to the data dictionary. It then puts the data into the specified table. If the manual_run flag is set and the table is \"Trial.StateOnset\", it prints the state.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The name of the table in the experiment database.</p> required <code>data</code> <code>dict</code> <p>The data to be logged. Defaults to an empty dictionary.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the put method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>The elapsed time from the logger timer.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def log(self, table, data=None, **kwargs):\n    \"\"\"\n    This method logs the given data into the specified table in the experiment database.\n\n    It first gets the elapsed time from the logger timer and adds it to the data dictionary.\n    It then puts the data into the specified table. If the manual_run flag is set and the\n    table is \"Trial.StateOnset\",\n    it prints the state.\n\n    Args:\n        table (str): The name of the table in the experiment database.\n        data (dict, optional): The data to be logged. Defaults to an empty dictionary.\n        **kwargs: Additional keyword arguments to be passed to the put method.\n\n    Returns:\n        float: The elapsed time from the logger timer.\n    \"\"\"\n    tmst = self.logger_timer.elapsed_time()\n    data = data or {}\n    self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n    if self.manual_run and table == \"Trial.StateOnset\":\n        print(\"State: \", data[\"state\"])\n    return tmst\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.log_session","title":"<code>log_session(self, params, log_protocol=False)</code>","text":"<p>Logs a session with the given parameters and optionally logs the protocol.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Dict[str, Any]</code> <p>Parameters for the session.</p> required <code>log_protocol</code> <code>bool</code> <p>Whether to log the protocol information.</p> <code>False</code> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def log_session(self, params: Dict[str, Any], log_protocol: bool = False) -&gt; None:\n    \"\"\"\n    Logs a session with the given parameters and optionally logs the protocol.\n\n    Args:\n        params (Dict[str, Any]): Parameters for the session.\n        log_protocol (bool): Whether to log the protocol information.\n    \"\"\"\n    self._initialize_session()\n    session_key = self._create_session_key(params)\n    self._log_session_entry(session_key)\n\n    if log_protocol:\n        self._log_protocol()\n\n    self._log_configuration()\n    self._log_additional_configurations(params)\n    self._set_setup_status(params)\n\n    self.logger_timer.start()  # Start session time\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.put","title":"<code>put(self, **kwargs)</code>","text":"<p>Put an item in the queue.</p> <p>**kwargs (Any): The item to put in the queue.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def put(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Put an item in the queue.\n\n    Parameters:\n    **kwargs (Any): The item to put in the queue.\n    \"\"\"\n    item = PrioritizedItem(**kwargs)\n    self.queue.put(item)\n    if not item.block:\n        self.queue.task_done()\n    else:\n        self.queue.join()\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.setup_schema","title":"<code>setup_schema(self, extra_schema)</code>","text":"<p>Set up additional schema.</p> <p>extra_schema (Dict[str, Any]): The additional schema to set up.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set up additional schema.\n\n    Args:\n    extra_schema (Dict[str, Any]): The additional schema to set up.\n    \"\"\"\n    for schema, value in extra_schema.items():\n        globals()[schema] = dj.create_virtual_module(\n            schema, value, create_tables=True, create_schema=True\n        )\n        self._schemata.update(\n            {\n                schema: dj.create_virtual_module(\n                    schema, value, connection=self.private_conn\n                )\n            }\n        )\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.update_protocol","title":"<code>update_protocol(self)</code>","text":"<p>This method updates the protocol path based on the current setup.</p> <p>If the run is manual, it checks if the protocol file exists at the specified path. If the file does not exist, it prints an error message and returns False.</p> <p>If the run is not manual, it fetches the task index from the setup info. It then checks if there is a task with this index in the experiment's Task table. If there is no such task, it returns False. Otherwise, it fetches the protocol associated with this task and updates the protocol path.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the protocol path was successfully updated, False otherwise.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def update_protocol(self):\n    \"\"\"\n    This method updates the protocol path based on the current setup.\n\n    If the run is manual, it checks if the protocol file exists at the specified path.\n    If the file does not exist, it prints an error message and returns False.\n\n    If the run is not manual, it fetches the task index from the setup info.\n    It then checks if there is a task with this index in the experiment's Task table.\n    If there is no such task, it returns False.\n    Otherwise, it fetches the protocol associated with this task and updates the protocol path.\n\n    Returns:\n        bool: True if the protocol path was successfully updated, False otherwise.\n    \"\"\"\n    if self.manual_run:\n        if not os.path.isfile(self.protocol_path):\n            print(f\"Protocol file {self.protocol_path} not found!\")\n            return False\n    else:\n        task_idx = self.get_setup_info('task_idx')\n        if not len(experiment.Task() &amp; dict(task_idx=task_idx)) &gt; 0:\n            return False\n        protocol = (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1('protocol')\n        self.protocol_path = protocol\n    return True\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.update_setup_info","title":"<code>update_setup_info(self, info, key=None)</code>","text":"<p>This method updates the setup information with the provided info and key.</p> <p>It first fetches the existing setup information from the experiment's Control table, then updates it with the provided info. If 'status' is in the provided info, it blocks and validates the update operation.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>dict</code> <p>The information to update the setup with.</p> required <code>key</code> <code>dict</code> <p>Additional keys to fetch the setup information with.</p> <code>None</code> <p>Side Effects:     Updates the setup_info attribute with the new setup information.     Updates the setup_status attribute with the new status.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def update_setup_info(self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None):\n    \"\"\"\n    This method updates the setup information with the provided info and key.\n\n    It first fetches the existing setup information from the experiment's Control table,\n    then updates it with the provided info. If 'status' is in the provided info, it blocks\n    and validates the update operation.\n\n    Args:\n        info (dict): The information to update the setup with.\n        key (dict, optional): Additional keys to fetch the setup information with.\n        Defaults to an empty dict.\n\n    Side Effects:\n        Updates the setup_info attribute with the new setup information.\n        Updates the setup_status attribute with the new status.\n    \"\"\"\n    if key is None:\n        key = dict()\n    self.setup_info = {\n        **(experiment.Control() &amp; {**{\"setup\": self.setup}, **key}).fetch1(),\n        **info,\n    }\n    block = True if \"status\" in info else False\n    self.put(\n        table=\"Control\",\n        tuple=self.setup_info,\n        replace=True,\n        priority=1,\n        block=block,\n        validate=block,\n    )\n    self.setup_status = self.setup_info[\"status\"]\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.Logger.validate_item","title":"<code>validate_item(self, item, table)</code>","text":"<p>Validates an item against a table.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def validate_item(self, item, table):\n    \"\"\"\n    Validates an item against a table.\n    \"\"\"\n    if item.validate:  # validate tuple exists in database\n        key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n        if \"status\" in item.tuple.keys():\n            key[\"status\"] = item.tuple[\"status\"]\n        while not len(table &amp; key) &gt; 0:\n            time.sleep(0.5)\n</code></pre>"},{"location":"logger/#ethopy.core.Logger.PrioritizedItem","title":"<code> PrioritizedItem        </code>  <code>dataclass</code>","text":"<p>PrioritizedItem(table: str, tuple: Any, field: str = '', value: Any = '', schema: str = 'experiment', replace: bool = False, block: bool = False, validate: bool = False, priority: int = 50, error: bool = False, ignore_extra_fields: bool = True)</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>class PrioritizedItem:\n    table: str = datafield(compare=False)\n    tuple: Any = datafield(compare=False)\n    field: str = datafield(compare=False, default=\"\")\n    value: Any = datafield(compare=False, default=\"\")\n    schema: str = datafield(compare=False, default=\"experiment\")\n    replace: bool = datafield(compare=False, default=False)\n    block: bool = datafield(compare=False, default=False)\n    validate: bool = datafield(compare=False, default=False)\n    priority: int = datafield(default=50)\n    error: bool = datafield(compare=False, default=False)\n    ignore_extra_fields: bool = datafield(compare=False, default=True)\n</code></pre>"},{"location":"stimulus/","title":"Core Stimulus module","text":""},{"location":"usage/","title":"Usage","text":"<p>To use EthoPy in a project:</p> <pre><code>import ethopy\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}