{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ethopy","text":"<p>Python Boilerplate contains all the boilerplate you need to create a Python package.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://alexevag.github.io/ethopy</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#ethopy.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>ethopy/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/alexevag/testcore/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>EthoPy could always use more documentation, whether as part of the official EthoPy docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/alexevag/testcore/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up testcore for local development.</p> <ol> <li> <p>Fork the testcore repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/testcore.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv testcore\n$ cd testcore/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 testcore tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/alexevag/testcore/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"core.Logger/","title":"Core Logger module","text":""},{"location":"core.Logger/#ethopy.core.Logger.Logger","title":"<code> Logger        </code>","text":"Source code in <code>ethopy/core/Logger.py</code> <pre><code>class Logger:\n    DEFAULT_SOURCE_PATH = os.path.expanduser(\"~\") + \"/EthoPy_Files/\"\n    DEFAULT_TARGET_PATH = False\n\n    def __init__(self, protocol=False):\n\n        self.setup = socket.gethostname()\n        self.is_pi = self._check_if_raspberry_pi()\n\n        self.task_idx, self.protocol_path = self._parse_protocol(protocol)\n\n        self.manual_run = True if self.protocol_path else False\n\n        self.setup_status = \"running\" if self.manual_run else \"ready\"\n\n        self.writer = Writer\n        self.rec_fliptimes = True\n        self.trial_key = {'animal_id': 0, 'session': 1, 'trial_idx': 0}\n        self.setup_info = {}\n        self.datasets = {}\n        self.lock = False\n        self.queue = PriorityQueue()\n        self.ping_timer = Timer()\n        self.logger_timer = Timer()\n        self.total_reward = 0\n        self.curr_state = \"\"\n\n        # separate connection for internal communication\n        self.private_conn = dj.Connection(\n            dj.config[\"database.host\"],\n            dj.config[\"database.user\"],\n            dj.config[\"database.password\"],\n        )\n        self._schemata = self._initialize_schemata()\n\n        self.source_path = self.get_path(\"source_path\", self.DEFAULT_SOURCE_PATH)\n        self.target_path = self.get_path(\"target_path\", self.DEFAULT_TARGET_PATH)\n\n        self.thread_end, self.thread_lock = threading.Event(), threading.Lock()\n        self.inserter_thread = threading.Thread(target=self.inserter)\n        self.getter_thread = threading.Thread(target=self._sync_setup_info)\n        self.inserter_thread.start()\n        self._log_setup(self.task_idx)\n        self.getter_thread.start()\n        self.logger_timer.start()\n\n    def _parse_protocol(self, protocol):\n        if protocol and protocol.isdigit():\n            print(\"int protocol\", int(protocol), self._find_protocol_path(int(protocol)))\n            return int(protocol), self._find_protocol_path(int(protocol))\n        elif protocol and isinstance(protocol, str):\n            print(\"_validate_protocol protocol\", protocol)\n            return None, protocol\n        else:\n            return None, None\n\n    def update_protocol(self):\n        \"\"\"\n        This method updates the protocol path based on the current setup.\n\n        If the run is manual, it checks if the protocol file exists at the specified path.\n        If the file does not exist, it prints an error message and returns False.\n\n        If the run is not manual, it fetches the task index from the setup info.\n        It then checks if there is a task with this index in the experiment's Task table.\n        If there is no such task, it returns False.\n        Otherwise, it fetches the protocol associated with this task and updates the protocol path.\n\n        Returns:\n            bool: True if the protocol path was successfully updated, False otherwise.\n        \"\"\"\n        if self.manual_run:\n            if not os.path.isfile(self.protocol_path):\n                print(f\"Protocol file {self.protocol_path} not found!\")\n                return False\n        else:\n            task_idx = self.get_setup_info('task_idx')\n            if not len(experiment.Task() &amp; dict(task_idx=task_idx)) &gt; 0:\n                return False\n            protocol = (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1('protocol')\n            self.protocol_path = protocol\n        return True\n\n    @property\n    def protocol_path(self) -&gt; str:\n        \"\"\"\n        Get the protocol path.\n\n        Returns:\n            str: The protocol path.\n        \"\"\"\n        return self._protocol_path\n\n    @protocol_path.setter\n    def protocol_path(self, protocol_path: str):\n        \"\"\"\n        Set the protocol path. if protocol_path has only filename\n        set the protocol_path at the conf directory.\n\n        Args:\n            protocol_path (str): The protocol path.\n        \"\"\"\n\n        if protocol_path is not None:\n            path, filename = os.path.split(protocol_path)\n            print(path, filename)\n            if not path:\n                protocol_path = (\n                    str(pathlib.Path(__file__).parent.absolute()) + \"/../conf/\" + filename\n                )\n        self._protocol_path = protocol_path\n\n    def _find_protocol_path(self, task_idx=None):\n        \"\"\"find the protocol path from the task index\"\"\"\n        if task_idx:\n            return (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1(\"protocol\")\n        else:\n            return False\n\n    def _initialize_schemata(self) -&gt; Dict[str, dj.VirtualModule]:\n        return {\n            schema: dj.create_virtual_module(\n                schema, value, connection=self.private_conn\n            )\n            for schema, value in SCHEMATA.items()\n        }\n\n    def _check_if_raspberry_pi(self) -&gt; bool:\n        system = platform.uname()\n        return (\n            system.machine.startswith(\"arm\") or system.machine == \"aarch64\"\n            if system.system == \"Linux\"\n            else False\n        )\n\n    def get_path(self, path_key: str, default_path: str) -&gt; str:\n        \"\"\"\n        Get the path from the configuration or create a new directory at the default path.\n\n        Args:\n        path_key (str): The key to look up in the configuration.\n        default_path (str): The path to use if the key is not in the configuration.\n\n        Returns:\n        str: The path from the configuration or the default path.\n        \"\"\"\n        path = config.get(path_key, default_path)\n        if path:\n            os.makedirs(path, exist_ok=True)\n            print(f\"Setting storage directory: {path}\")\n        return path\n\n    def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set up additional schema.\n\n        Args:\n        extra_schema (Dict[str, Any]): The additional schema to set up.\n        \"\"\"\n        for schema, value in extra_schema.items():\n            globals()[schema] = dj.create_virtual_module(\n                schema, value, create_tables=True, create_schema=True\n            )\n            self._schemata.update(\n                {\n                    schema: dj.create_virtual_module(\n                        schema, value, connection=self.private_conn\n                    )\n                }\n            )\n\n    def put(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Put an item in the queue.\n\n        Parameters:\n        **kwargs (Any): The item to put in the queue.\n        \"\"\"\n        item = PrioritizedItem(**kwargs)\n        self.queue.put(item)\n        if not item.block:\n            self.queue.task_done()\n        else:\n            self.queue.join()\n\n    def insert_item(self, item, table):\n        \"\"\"\n        Inserts an item into the specified table.\n\n        Args:\n            item: The item to be inserted.\n            table: The table to insert the item into.\n\n        Returns:\n            None\n        \"\"\"\n        table.insert1(\n            item.tuple,\n            ignore_extra_fields=item.ignore_extra_fields,\n            skip_duplicates=False if item.replace else True,\n            replace=item.replace,\n        )\n\n    def validate_item(self, item, table):\n        \"\"\"\n        Validates an item against a table.\n        \"\"\"\n        if item.validate:  # validate tuple exists in database\n            key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n            if \"status\" in item.tuple.keys():\n                key[\"status\"] = item.tuple[\"status\"]\n            while not len(table &amp; key) &gt; 0:\n                time.sleep(0.5)\n\n    def handle_error(self, item, table, e, thread_end, queue):\n        \"\"\"\n        Handles an error by logging the error message and add the item again in the queue\n        and re-trying again later.\n\n        Parameters:\n        item : Description of parameter `item`.\n        table : Description of parameter `table`.\n        e (Exception): The exception that was raised.\n        thread_end : Description of parameter `thread_end`.\n        queue : Description of parameter `queue`.\n        \"\"\"\n        str_error = f\"Failed to insert:\\n{item.tuple}\\n in {table}\\n With error:\\n{e}\"\n        if item.error:\n            thread_end.set()\n            raise str_error + \"\\nSecond time...\"\n        print(str_error+\"\\nWill retry later\")\n        item.error = True\n        item.priority = item.priority + 2\n        queue.put(item)\n\n    def inserter(self):\n        \"\"\"\n        This method continuously inserts items from the queue into their respective tables in\n        the database.\n\n        It runs in a loop until the thread_end event is set. In each iteration, it checks if\n        the queue is empty.\n        If it is, it sleeps for 0.5 seconds and then continues to the next iteration.\n        If the queue is not empty.\n        it gets an item from the queue, acquires the thread lock, and tries to insert\n        the item into its table.\n        If an error occurs during the insertion, it handles the error.\n        After the insertion, it releases the thread lock.\n        If the item was marked to block, it marks the task as done.\n\n        Returns:\n            None\n        \"\"\"\n        while not self.thread_end.is_set():\n            if self.queue.empty():\n                time.sleep(0.5)\n                continue\n            item = self.queue.get()\n            table = rgetattr(self._schemata[item.schema], item.table)\n            self.thread_lock.acquire()\n            try:\n                self.insert_item(item, table)\n                self.validate_item(item, table)\n            except ValueError as e:\n                if item.error:\n                    self.thread_end.set()\n                    raise\n                self.handle_error(item, table, e, self.thread_end, self.queue)\n            self.thread_lock.release()\n            if item.block:\n                self.queue.task_done()\n\n    def _sync_setup_info(self):\n        \"\"\"\n        This method continuously updates the setup information and status from the experiment\n        database.\n\n        It runs in a loop until the thread_end event is set. In each iteration, it acquires the thread lock,\n        fetches the setup information from the Control table in the experiment database, releases the thread lock,\n        and updates the setup status. It then sleeps for 1 second before the next iteration.\n\n        Returns:\n            None\n        \"\"\"\n        while not self.thread_end.is_set():\n            self.thread_lock.acquire()\n            self.setup_info = (\n                self._schemata[\"experiment\"].Control() &amp; dict(setup=self.setup)\n            ).fetch1()\n            self.thread_lock.release()\n            self.setup_status = self.setup_info[\"status\"]\n            time.sleep(1)  # update once a second\n\n    def log(self, table, data=None, **kwargs):\n        \"\"\"\n        This method logs the given data into the specified table in the experiment database.\n\n        It first gets the elapsed time from the logger timer and adds it to the data dictionary.\n        It then puts the data into the specified table. If the manual_run flag is set and the\n        table is \"Trial.StateOnset\",\n        it prints the state.\n\n        Args:\n            table (str): The name of the table in the experiment database.\n            data (dict, optional): The data to be logged. Defaults to an empty dictionary.\n            **kwargs: Additional keyword arguments to be passed to the put method.\n\n        Returns:\n            float: The elapsed time from the logger timer.\n        \"\"\"\n        tmst = self.logger_timer.elapsed_time()\n        data = data or {}\n        self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n        if self.manual_run and table == \"Trial.StateOnset\":\n            print(\"State: \", data[\"state\"])\n        return tmst\n\n    def _log_setup(self, task=None):\n        \"\"\"\n        This method logs the setup information into the Control table in the experiment database.\n\n        It first fetches the control information for the current setup. If no control information is found,\n        it creates a new dictionary with the setup information. If a task is provided and it is an integer,\n        it adds the task index to the key. It then adds the IP and status information to the key.\n\n        The method finally puts the key into the Control table, replacing any existing entry with the same key.\n        It blocks until the operation is complete and validates the operation.\n\n        Args:\n            task (int, optional): The task index. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        rel = experiment.Control() &amp; dict(setup=self.setup)\n        key = rel.fetch1() if np.size(rel.fetch()) else dict(setup=self.setup)\n        if task and isinstance(task, int):\n            key[\"task_idx\"] = task\n        key = {**key, \"ip\": self.get_ip(), \"status\": self.setup_status}\n        self.put(\n            table=\"Control\",\n            tuple=key,\n            replace=True,\n            priority=1,\n            block=True,\n            validate=True,\n        )\n\n    def _get_last_session(self):\n        \"\"\"\n        This method fetches the last session for a given animal_id from the experiment.Session.\n\n        It first fetches all sessions for the given animal_id. If no sessions are found,\n        it returns 0.\n        If sessions are found, it returns the maximum session number, which corresponds to\n        the last session.\n\n        Returns:\n            int: The last session number or 0 if no sessions are found.\n        \"\"\"\n        last_sessions = (\n            experiment.Session() &amp; dict(animal_id=self.get_setup_info(\"animal_id\"))\n        ).fetch(\"session\")\n        return 0 if np.size(last_sessions) == 0 else np.max(last_sessions)\n\n    def log_session(self, params: Dict[str, Any], log_protocol: bool = False) -&gt; None:\n        \"\"\"\n        Logs a session with the given parameters and optionally logs the protocol.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n            log_protocol (bool): Whether to log the protocol information.\n        \"\"\"\n        self._initialize_session()\n        session_key = self._create_session_key(params)\n        self._log_session_entry(session_key)\n\n        if log_protocol:\n            self._log_protocol()\n\n        self._log_configuration()\n        self._log_additional_configurations(params)\n        self._set_setup_status(params)\n\n        self.logger_timer.start()  # Start session time\n\n    def _initialize_session(self) -&gt; None:\n        \"\"\"\n        Initializes session attributes.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        self.total_reward = 0\n        self.trial_key = {\n            \"animal_id\": self.get_setup_info(\"animal_id\"),\n            \"trial_idx\": 0,\n            \"session\": self._get_last_session() + 1,\n        }\n\n    def _create_session_key(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Creates a session key by merging trial key with session parameters.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n\n        Returns:\n            Dict[str, Any]: The complete session key.\n        \"\"\"\n        return {\n            **self.trial_key,\n            **params,\n            \"setup\": self.setup,\n            \"user_name\": params.get(\"user_name\", \"bot\"),\n        }\n\n    def _log_session_entry(self, session_key: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Logs the session entry to the database.\n\n        Args:\n            session_key (Dict[str, Any]): The session key to log.\n        \"\"\"\n        if self.manual_run:\n            print(\"Logging Session:\")\n            pprint.pprint(session_key)\n        self.put(\n            table=\"Session\", tuple=session_key, priority=1, validate=True, block=True\n        )\n\n    def _log_protocol(self) -&gt; None:\n        \"\"\"\n        Logs the protocol information to the database.\n        \"\"\"\n        pr_name = self.protocol_path\n        pr_file = np.fromfile(self.protocol_path, dtype=np.int8)\n        git_hash = (\n            subprocess.check_output([\"git\", \"rev-parse\", \"--short\", \"HEAD\"])\n            .decode(\"ascii\")\n            .strip()\n        )\n        self.put(\n            table=\"Session.Protocol\",\n            tuple={\n                **self.trial_key,\n                \"protocol_name\": pr_name,\n                \"protocol_file\": pr_file,\n                \"git_hash\": git_hash,\n            },\n        )\n\n    def _log_configuration(self) -&gt; None:\n        \"\"\"\n        Logs the basic configuration to the database.\n        \"\"\"\n        self.put(\n            table=\"Configuration\",\n            tuple=self.trial_key,\n            schema=\"behavior\",\n            priority=2,\n            validate=True,\n            block=True,\n        )\n        self.put(\n            table=\"Configuration\",\n            tuple=self.trial_key,\n            schema=\"stimulus\",\n            priority=2,\n            validate=True,\n            block=True,\n        )\n\n    def _log_additional_configurations(self, params: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Logs additional configurations like ports, screens, balls, and speakers.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        configurations = [\n            (\"Port\", \"behavior\"),\n            (\"Screen\", \"stimulus\"),\n            (\"Ball\", \"behavior\"),\n            (\"Speaker\", \"stimulus\"),\n        ]\n        for config_type, schema in configurations:\n            self._log_individual_configuration(params, config_type, schema)\n\n    def _log_individual_configuration(\n        self, params: Dict[str, Any], config_type: str, schema: str\n    ) -&gt; None:\n        \"\"\"\n        Logs individual configuration type to the database.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n            config_type (str): The type of configuration (e.g., Port, Screen).\n            schema (str): The schema for the configuration.\n        \"\"\"\n        configuration_data = (\n            getattr(experiment.SetupConfiguration, config_type)\n            &amp; {\"setup_conf_idx\": params[\"setup_conf_idx\"]}\n        ).fetch(as_dict=True)\n        for conf in configuration_data:\n            self.put(\n                table=f\"Configuration.{config_type}\",\n                tuple={**conf, **self.trial_key},\n                schema=schema,\n            )\n\n    def _set_setup_status(self, params: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Sets the setup status and updates setup information.\n\n        Args:\n            params (Dict[str, Any]): Parameters for the session.\n        \"\"\"\n        key = {\n            \"session\": self.trial_key[\"session\"],\n            \"trials\": 0,\n            \"total_liquid\": 0,\n            \"difficulty\": 1,\n            \"state\": \"\",\n        }\n        # if in the start_time is defined in the configuration use this\n        # otherwise use the Control table\n        if \"start_time\" in params:\n\n            def tdelta(t):\n                return datetime.strptime(t, \"%H:%M:%S\") - datetime.strptime(\n                    \"00:00:00\", \"%H:%M:%S\"\n                )\n\n            key.update(\n                {\n                    \"start_time\": str(tdelta(params[\"start_time\"])),\n                    \"stop_time\": str(tdelta(params[\"stop_time\"])),\n                }\n            )\n\n        self.update_setup_info({**key, \"status\": self.setup_info[\"status\"]})\n\n    def update_setup_info(self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        This method updates the setup information with the provided info and key.\n\n        It first fetches the existing setup information from the experiment's Control table,\n        then updates it with the provided info. If 'status' is in the provided info, it blocks\n        and validates the update operation.\n\n        Args:\n            info (dict): The information to update the setup with.\n            key (dict, optional): Additional keys to fetch the setup information with.\n            Defaults to an empty dict.\n\n        Side Effects:\n            Updates the setup_info attribute with the new setup information.\n            Updates the setup_status attribute with the new status.\n        \"\"\"\n        if key is None:\n            key = dict()\n        self.setup_info = {\n            **(experiment.Control() &amp; {**{\"setup\": self.setup}, **key}).fetch1(),\n            **info,\n        }\n        block = True if \"status\" in info else False\n        self.put(\n            table=\"Control\",\n            tuple=self.setup_info,\n            replace=True,\n            priority=1,\n            block=block,\n            validate=block,\n        )\n        self.setup_status = self.setup_info[\"status\"]\n\n    def get_setup_info(self, field):\n        return (experiment.Control() &amp; dict(setup=self.setup)).fetch1(field)\n\n    def get(\n        self,\n        schema: str = \"experiment\",\n        table: str = \"Control\",\n        fields: str = \"\",\n        key: Dict[str, Any] = dict(),\n        **kwargs: Any\n    ) -&gt; Any:\n        \"\"\"\n        Fetches data from a specified table in a schema.\n\n        Parameters:\n        schema (str): The schema to fetch data from. Defaults to \"experiment\".\n        table (str): The table to fetch data from. Defaults to \"Control\".\n        fields (str): The fields to fetch. Defaults to \"\".\n        key (dict): The key used to fetch data. Defaults to an empty dict.\n        **kwargs: Additional keyword arguments.\n\n        Returns:\n        The fetched data.\n        \"\"\"\n        _table = rgetattr(eval(schema), table)\n        return (_table() &amp; key).fetch(*fields, **kwargs)\n\n    def update_trial_idx(self, trial_idx):\n        self.trial_key[\"trial_idx\"] = trial_idx\n\n    def ping(self, period=5000):\n        if (\n            self.ping_timer.elapsed_time() &gt;= period\n        ):  # occasionally update control table\n            self.ping_timer.start()\n            self.update_setup_info(\n                {\n                    \"last_ping\": str(datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")),\n                    \"queue_size\": self.queue.qsize(),\n                    \"trials\": self.trial_key[\"trial_idx\"],\n                    \"total_liquid\": self.total_reward,\n                    \"state\": self.curr_state,\n                }\n            )\n\n    def cleanup(self):\n        while not self.queue.empty():\n            print(\"Waiting for empty queue... qsize: %d\" % self.queue.qsize())\n            time.sleep(1)\n        self.thread_end.set()\n\n    def createDataset(\n        self,\n        dataset_name: str,\n        dataset_type: type,\n        filename: Optional[str] = None,\n        log: Optional[bool] = True,\n    ) -&gt; Any:\n        \"\"\"\n        Create a dataset and return the dataset object.\n        Args:\n            target_path (str): The target path for the dataset.\n            dataset_name (str): The name of the dataset.\n            dataset_type (type): The datatype of the dataset.\n            filename (str, optional): The filename for the h5 file. If not provided,\n            a default filename will be generated based on the dataset name, animal ID,\n            session, and current timestamp.\n            log (bool, optional): If True call the log_recording\n        Returns:\n            Tuple[str, Any]: A tuple containing the filename and the dataset object.\n        \"\"\"\n        folder = (\n            f\"Recordings/{self.trial_key['animal_id']}\" f\"_{self.trial_key['session']}/\"\n        )\n        path = self.source_path + folder\n        if not os.path.isdir(path):\n            os.makedirs(path)  # create path if necessary\n\n        if not os.path.isdir(self.target_path):\n            print(\"No target directory set! Autocopying will not work.\")\n            target_path = None\n        else:\n            target_path = self.target_path + folder\n            if not os.path.isdir(target_path):\n                os.makedirs(target_path)\n\n        # Generate filename if not provided\n        if filename is None:\n            filename = \"%s_%d_%d_%s.h5\" % (\n                dataset_name,\n                self.trial_key[\"animal_id\"],\n                self.trial_key[\"session\"],\n                datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\"),\n            )\n\n        if filename not in self.datasets:\n            # create h5 file if not exists\n            self.datasets[filename] = self.writer(path + filename, target_path)\n\n        # create new dataset in the h5 files\n        self.datasets[filename].createDataset(\n            dataset_name, shape=(1,), dtype=dataset_type\n        )\n\n        if log:\n            rec_key = dict(\n                rec_aim=dataset_name,\n                software=\"EthoPy\",\n                version=VERSION,\n                filename=filename,\n                source_path=path,\n                target_path=target_path,\n            )\n            self.log_recording(rec_key)\n\n        return self.datasets[filename]\n\n    def log_recording(self, rec_key):\n        recs = self.get(\n            schema=\"recording\",\n            table=\"Recording\",\n            key=self.trial_key,\n            fields=[\"rec_idx\"],\n        )\n        rec_idx = 1 if not recs else max(recs) + 1\n        self.log(\"Recording\", data={**rec_key, \"rec_idx\": rec_idx}, schema=\"recording\")\n\n    def closeDatasets(self):\n        for dataset in self.datasets:\n            self.datasets[dataset].exit()\n\n    @staticmethod\n    def get_ip():\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        try:\n            s.connect((\"8.8.8.8\", 80))\n            ip = s.getsockname()[0]\n        except Exception:\n            ip = \"127.0.0.1\"\n        finally:\n            s.close()\n        return ip\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.protocol_path","title":"<code>protocol_path: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the protocol path.</p> <p>Returns:</p> Type Description <code>str</code> <p>The protocol path.</p>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.createDataset","title":"<code>createDataset(self, dataset_name, dataset_type, filename=None, log=True)</code>","text":"<p>Create a dataset and return the dataset object.</p> <p>Parameters:</p> Name Type Description Default <code>target_path</code> <code>str</code> <p>The target path for the dataset.</p> required <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>dataset_type</code> <code>type</code> <p>The datatype of the dataset.</p> required <code>filename</code> <code>str</code> <p>The filename for the h5 file. If not provided,</p> <code>None</code> <code>log</code> <code>bool</code> <p>If True call the log_recording</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[str, Any]</code> <p>A tuple containing the filename and the dataset object.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def createDataset(\n    self,\n    dataset_name: str,\n    dataset_type: type,\n    filename: Optional[str] = None,\n    log: Optional[bool] = True,\n) -&gt; Any:\n    \"\"\"\n    Create a dataset and return the dataset object.\n    Args:\n        target_path (str): The target path for the dataset.\n        dataset_name (str): The name of the dataset.\n        dataset_type (type): The datatype of the dataset.\n        filename (str, optional): The filename for the h5 file. If not provided,\n        a default filename will be generated based on the dataset name, animal ID,\n        session, and current timestamp.\n        log (bool, optional): If True call the log_recording\n    Returns:\n        Tuple[str, Any]: A tuple containing the filename and the dataset object.\n    \"\"\"\n    folder = (\n        f\"Recordings/{self.trial_key['animal_id']}\" f\"_{self.trial_key['session']}/\"\n    )\n    path = self.source_path + folder\n    if not os.path.isdir(path):\n        os.makedirs(path)  # create path if necessary\n\n    if not os.path.isdir(self.target_path):\n        print(\"No target directory set! Autocopying will not work.\")\n        target_path = None\n    else:\n        target_path = self.target_path + folder\n        if not os.path.isdir(target_path):\n            os.makedirs(target_path)\n\n    # Generate filename if not provided\n    if filename is None:\n        filename = \"%s_%d_%d_%s.h5\" % (\n            dataset_name,\n            self.trial_key[\"animal_id\"],\n            self.trial_key[\"session\"],\n            datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\"),\n        )\n\n    if filename not in self.datasets:\n        # create h5 file if not exists\n        self.datasets[filename] = self.writer(path + filename, target_path)\n\n    # create new dataset in the h5 files\n    self.datasets[filename].createDataset(\n        dataset_name, shape=(1,), dtype=dataset_type\n    )\n\n    if log:\n        rec_key = dict(\n            rec_aim=dataset_name,\n            software=\"EthoPy\",\n            version=VERSION,\n            filename=filename,\n            source_path=path,\n            target_path=target_path,\n        )\n        self.log_recording(rec_key)\n\n    return self.datasets[filename]\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.get","title":"<code>get(self, schema='experiment', table='Control', fields='', key={}, **kwargs)</code>","text":"<p>Fetches data from a specified table in a schema.</p> <p>schema (str): The schema to fetch data from. Defaults to \"experiment\". table (str): The table to fetch data from. Defaults to \"Control\". fields (str): The fields to fetch. Defaults to \"\". key (dict): The key used to fetch data. Defaults to an empty dict. **kwargs: Additional keyword arguments.</p> <p>The fetched data.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def get(\n    self,\n    schema: str = \"experiment\",\n    table: str = \"Control\",\n    fields: str = \"\",\n    key: Dict[str, Any] = dict(),\n    **kwargs: Any\n) -&gt; Any:\n    \"\"\"\n    Fetches data from a specified table in a schema.\n\n    Parameters:\n    schema (str): The schema to fetch data from. Defaults to \"experiment\".\n    table (str): The table to fetch data from. Defaults to \"Control\".\n    fields (str): The fields to fetch. Defaults to \"\".\n    key (dict): The key used to fetch data. Defaults to an empty dict.\n    **kwargs: Additional keyword arguments.\n\n    Returns:\n    The fetched data.\n    \"\"\"\n    _table = rgetattr(eval(schema), table)\n    return (_table() &amp; key).fetch(*fields, **kwargs)\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.get_path","title":"<code>get_path(self, path_key, default_path)</code>","text":"<p>Get the path from the configuration or create a new directory at the default path.</p> <p>path_key (str): The key to look up in the configuration. default_path (str): The path to use if the key is not in the configuration.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def get_path(self, path_key: str, default_path: str) -&gt; str:\n    \"\"\"\n    Get the path from the configuration or create a new directory at the default path.\n\n    Args:\n    path_key (str): The key to look up in the configuration.\n    default_path (str): The path to use if the key is not in the configuration.\n\n    Returns:\n    str: The path from the configuration or the default path.\n    \"\"\"\n    path = config.get(path_key, default_path)\n    if path:\n        os.makedirs(path, exist_ok=True)\n        print(f\"Setting storage directory: {path}\")\n    return path\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.handle_error","title":"<code>handle_error(self, item, table, e, thread_end, queue)</code>","text":"<p>Handles an error by logging the error message and add the item again in the queue and re-trying again later.</p> <p>item : Description of parameter <code>item</code>. table : Description of parameter <code>table</code>. e (Exception): The exception that was raised. thread_end : Description of parameter <code>thread_end</code>. queue : Description of parameter <code>queue</code>.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def handle_error(self, item, table, e, thread_end, queue):\n    \"\"\"\n    Handles an error by logging the error message and add the item again in the queue\n    and re-trying again later.\n\n    Parameters:\n    item : Description of parameter `item`.\n    table : Description of parameter `table`.\n    e (Exception): The exception that was raised.\n    thread_end : Description of parameter `thread_end`.\n    queue : Description of parameter `queue`.\n    \"\"\"\n    str_error = f\"Failed to insert:\\n{item.tuple}\\n in {table}\\n With error:\\n{e}\"\n    if item.error:\n        thread_end.set()\n        raise str_error + \"\\nSecond time...\"\n    print(str_error+\"\\nWill retry later\")\n    item.error = True\n    item.priority = item.priority + 2\n    queue.put(item)\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.insert_item","title":"<code>insert_item(self, item, table)</code>","text":"<p>Inserts an item into the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The item to be inserted.</p> required <code>table</code> <p>The table to insert the item into.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def insert_item(self, item, table):\n    \"\"\"\n    Inserts an item into the specified table.\n\n    Args:\n        item: The item to be inserted.\n        table: The table to insert the item into.\n\n    Returns:\n        None\n    \"\"\"\n    table.insert1(\n        item.tuple,\n        ignore_extra_fields=item.ignore_extra_fields,\n        skip_duplicates=False if item.replace else True,\n        replace=item.replace,\n    )\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.inserter","title":"<code>inserter(self)</code>","text":"<p>This method continuously inserts items from the queue into their respective tables in the database.</p> <p>It runs in a loop until the thread_end event is set. In each iteration, it checks if the queue is empty. If it is, it sleeps for 0.5 seconds and then continues to the next iteration. If the queue is not empty. it gets an item from the queue, acquires the thread lock, and tries to insert the item into its table. If an error occurs during the insertion, it handles the error. After the insertion, it releases the thread lock. If the item was marked to block, it marks the task as done.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def inserter(self):\n    \"\"\"\n    This method continuously inserts items from the queue into their respective tables in\n    the database.\n\n    It runs in a loop until the thread_end event is set. In each iteration, it checks if\n    the queue is empty.\n    If it is, it sleeps for 0.5 seconds and then continues to the next iteration.\n    If the queue is not empty.\n    it gets an item from the queue, acquires the thread lock, and tries to insert\n    the item into its table.\n    If an error occurs during the insertion, it handles the error.\n    After the insertion, it releases the thread lock.\n    If the item was marked to block, it marks the task as done.\n\n    Returns:\n        None\n    \"\"\"\n    while not self.thread_end.is_set():\n        if self.queue.empty():\n            time.sleep(0.5)\n            continue\n        item = self.queue.get()\n        table = rgetattr(self._schemata[item.schema], item.table)\n        self.thread_lock.acquire()\n        try:\n            self.insert_item(item, table)\n            self.validate_item(item, table)\n        except ValueError as e:\n            if item.error:\n                self.thread_end.set()\n                raise\n            self.handle_error(item, table, e, self.thread_end, self.queue)\n        self.thread_lock.release()\n        if item.block:\n            self.queue.task_done()\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.log","title":"<code>log(self, table, data=None, **kwargs)</code>","text":"<p>This method logs the given data into the specified table in the experiment database.</p> <p>It first gets the elapsed time from the logger timer and adds it to the data dictionary. It then puts the data into the specified table. If the manual_run flag is set and the table is \"Trial.StateOnset\", it prints the state.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The name of the table in the experiment database.</p> required <code>data</code> <code>dict</code> <p>The data to be logged. Defaults to an empty dictionary.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the put method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>The elapsed time from the logger timer.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def log(self, table, data=None, **kwargs):\n    \"\"\"\n    This method logs the given data into the specified table in the experiment database.\n\n    It first gets the elapsed time from the logger timer and adds it to the data dictionary.\n    It then puts the data into the specified table. If the manual_run flag is set and the\n    table is \"Trial.StateOnset\",\n    it prints the state.\n\n    Args:\n        table (str): The name of the table in the experiment database.\n        data (dict, optional): The data to be logged. Defaults to an empty dictionary.\n        **kwargs: Additional keyword arguments to be passed to the put method.\n\n    Returns:\n        float: The elapsed time from the logger timer.\n    \"\"\"\n    tmst = self.logger_timer.elapsed_time()\n    data = data or {}\n    self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n    if self.manual_run and table == \"Trial.StateOnset\":\n        print(\"State: \", data[\"state\"])\n    return tmst\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.log_session","title":"<code>log_session(self, params, log_protocol=False)</code>","text":"<p>Logs a session with the given parameters and optionally logs the protocol.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Dict[str, Any]</code> <p>Parameters for the session.</p> required <code>log_protocol</code> <code>bool</code> <p>Whether to log the protocol information.</p> <code>False</code> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def log_session(self, params: Dict[str, Any], log_protocol: bool = False) -&gt; None:\n    \"\"\"\n    Logs a session with the given parameters and optionally logs the protocol.\n\n    Args:\n        params (Dict[str, Any]): Parameters for the session.\n        log_protocol (bool): Whether to log the protocol information.\n    \"\"\"\n    self._initialize_session()\n    session_key = self._create_session_key(params)\n    self._log_session_entry(session_key)\n\n    if log_protocol:\n        self._log_protocol()\n\n    self._log_configuration()\n    self._log_additional_configurations(params)\n    self._set_setup_status(params)\n\n    self.logger_timer.start()  # Start session time\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.put","title":"<code>put(self, **kwargs)</code>","text":"<p>Put an item in the queue.</p> <p>**kwargs (Any): The item to put in the queue.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def put(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Put an item in the queue.\n\n    Parameters:\n    **kwargs (Any): The item to put in the queue.\n    \"\"\"\n    item = PrioritizedItem(**kwargs)\n    self.queue.put(item)\n    if not item.block:\n        self.queue.task_done()\n    else:\n        self.queue.join()\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.setup_schema","title":"<code>setup_schema(self, extra_schema)</code>","text":"<p>Set up additional schema.</p> <p>extra_schema (Dict[str, Any]): The additional schema to set up.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set up additional schema.\n\n    Args:\n    extra_schema (Dict[str, Any]): The additional schema to set up.\n    \"\"\"\n    for schema, value in extra_schema.items():\n        globals()[schema] = dj.create_virtual_module(\n            schema, value, create_tables=True, create_schema=True\n        )\n        self._schemata.update(\n            {\n                schema: dj.create_virtual_module(\n                    schema, value, connection=self.private_conn\n                )\n            }\n        )\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.update_protocol","title":"<code>update_protocol(self)</code>","text":"<p>This method updates the protocol path based on the current setup.</p> <p>If the run is manual, it checks if the protocol file exists at the specified path. If the file does not exist, it prints an error message and returns False.</p> <p>If the run is not manual, it fetches the task index from the setup info. It then checks if there is a task with this index in the experiment's Task table. If there is no such task, it returns False. Otherwise, it fetches the protocol associated with this task and updates the protocol path.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the protocol path was successfully updated, False otherwise.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def update_protocol(self):\n    \"\"\"\n    This method updates the protocol path based on the current setup.\n\n    If the run is manual, it checks if the protocol file exists at the specified path.\n    If the file does not exist, it prints an error message and returns False.\n\n    If the run is not manual, it fetches the task index from the setup info.\n    It then checks if there is a task with this index in the experiment's Task table.\n    If there is no such task, it returns False.\n    Otherwise, it fetches the protocol associated with this task and updates the protocol path.\n\n    Returns:\n        bool: True if the protocol path was successfully updated, False otherwise.\n    \"\"\"\n    if self.manual_run:\n        if not os.path.isfile(self.protocol_path):\n            print(f\"Protocol file {self.protocol_path} not found!\")\n            return False\n    else:\n        task_idx = self.get_setup_info('task_idx')\n        if not len(experiment.Task() &amp; dict(task_idx=task_idx)) &gt; 0:\n            return False\n        protocol = (experiment.Task() &amp; dict(task_idx=task_idx)).fetch1('protocol')\n        self.protocol_path = protocol\n    return True\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.update_setup_info","title":"<code>update_setup_info(self, info, key=None)</code>","text":"<p>This method updates the setup information with the provided info and key.</p> <p>It first fetches the existing setup information from the experiment's Control table, then updates it with the provided info. If 'status' is in the provided info, it blocks and validates the update operation.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>dict</code> <p>The information to update the setup with.</p> required <code>key</code> <code>dict</code> <p>Additional keys to fetch the setup information with.</p> <code>None</code> <p>Side Effects:     Updates the setup_info attribute with the new setup information.     Updates the setup_status attribute with the new status.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def update_setup_info(self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None):\n    \"\"\"\n    This method updates the setup information with the provided info and key.\n\n    It first fetches the existing setup information from the experiment's Control table,\n    then updates it with the provided info. If 'status' is in the provided info, it blocks\n    and validates the update operation.\n\n    Args:\n        info (dict): The information to update the setup with.\n        key (dict, optional): Additional keys to fetch the setup information with.\n        Defaults to an empty dict.\n\n    Side Effects:\n        Updates the setup_info attribute with the new setup information.\n        Updates the setup_status attribute with the new status.\n    \"\"\"\n    if key is None:\n        key = dict()\n    self.setup_info = {\n        **(experiment.Control() &amp; {**{\"setup\": self.setup}, **key}).fetch1(),\n        **info,\n    }\n    block = True if \"status\" in info else False\n    self.put(\n        table=\"Control\",\n        tuple=self.setup_info,\n        replace=True,\n        priority=1,\n        block=block,\n        validate=block,\n    )\n    self.setup_status = self.setup_info[\"status\"]\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.Logger.validate_item","title":"<code>validate_item(self, item, table)</code>","text":"<p>Validates an item against a table.</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>def validate_item(self, item, table):\n    \"\"\"\n    Validates an item against a table.\n    \"\"\"\n    if item.validate:  # validate tuple exists in database\n        key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n        if \"status\" in item.tuple.keys():\n            key[\"status\"] = item.tuple[\"status\"]\n        while not len(table &amp; key) &gt; 0:\n            time.sleep(0.5)\n</code></pre>"},{"location":"core.Logger/#ethopy.core.Logger.PrioritizedItem","title":"<code> PrioritizedItem        </code>  <code>dataclass</code>","text":"<p>PrioritizedItem(table: str, tuple: Any, field: str = '', value: Any = '', schema: str = 'experiment', replace: bool = False, block: bool = False, validate: bool = False, priority: int = 50, error: bool = False, ignore_extra_fields: bool = True)</p> Source code in <code>ethopy/core/Logger.py</code> <pre><code>class PrioritizedItem:\n    table: str = datafield(compare=False)\n    tuple: Any = datafield(compare=False)\n    field: str = datafield(compare=False, default=\"\")\n    value: Any = datafield(compare=False, default=\"\")\n    schema: str = datafield(compare=False, default=\"experiment\")\n    replace: bool = datafield(compare=False, default=False)\n    block: bool = datafield(compare=False, default=False)\n    validate: bool = datafield(compare=False, default=False)\n    priority: int = datafield(default=50)\n    error: bool = datafield(compare=False, default=False)\n    ignore_extra_fields: bool = datafield(compare=False, default=True)\n</code></pre>"},{"location":"ethopy/","title":"ethopy module","text":""},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install EthoPy, run this command in your terminal:</p> <pre><code>pip install testcore\n</code></pre> <p>This is the preferred method to install EthoPy, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install EthoPy from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/alexevag/testcore\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use EthoPy in a project:</p> <pre><code>import ethopy\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}